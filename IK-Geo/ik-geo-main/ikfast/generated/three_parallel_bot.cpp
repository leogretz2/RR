/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2023-03-06 18:30:04.282313
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;
x0=IKsin(j[0]);
x1=IKsin(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[1]);
x4=IKcos(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKcos(j[4]);
x8=IKcos(j[0]);
x9=IKsin(j[4]);
x10=IKsin(j[5]);
x11=IKcos(j[5]);
x12=((1.0)*x0);
x13=((1.0)*x6);
x14=((1.0)*x8);
x15=((1.0)*x5);
x16=((2.0)*x5);
x17=((2.0)*x6);
x18=(x2*x3);
x19=(x1*x4);
x20=((-1.0)*x7);
x21=(x3*x4);
x22=(x7*x8);
x23=(x1*x2);
x24=(x0*x7);
x25=(x14*x9);
x26=(x12*x9);
x27=((1.0)*x21);
x28=(x0*x23);
x29=(x21*x8);
x30=(x12*x21);
x31=(x14*x23);
x32=(x19+x18);
x33=((((-1.0)*x23))+x27);
x34=(x32*x6);
x35=(x33*x5);
x36=((((-1.0)*x30))+x28);
x37=((((-1.0)*x31))+x29);
x38=(x12*((x19+x18)));
x39=((-1.0)*x38);
x40=(x36*x6);
x41=(x14*(((((-1.0)*x18))+(((-1.0)*x19)))));
x42=(x37*x6);
x43=(x36*x5);
x44=(x38*x5);
x45=(x41*x5);
x46=(x35+x34);
x47=(((x13*(((((-1.0)*x23))+x27))))+(((-1.0)*x15*x32)));
x48=(x46*x7);
x49=(x44+x40);
x50=(x45+x42);
IkReal x54=((1.0)*x8);
x51=(((x13*(((((-1.0)*x19*x54))+(((-1.0)*x18*x54))))))+(((-1.0)*x15*x37)));
x52=(x49*x7);
x53=(x50*x7);
eerot[0]=(((x49*x9))+x22);
eerot[1]=(((x11*(((((-1.0)*x25))+x52))))+((x10*(((((-1.0)*x43))+(((-1.0)*x39*x6)))))));
eerot[2]=(((x10*((((x20*x49))+x25))))+((x11*(((((-1.0)*x13*x39))+(((-1.0)*x15*x36)))))));
IkReal x55=((1.0)*x12);
eetrans[0]=((((-1.0)*x30))+(((2.0)*x22))+(((-1.0)*x25))+((x9*((((x17*x36))+((x16*x38))))))+x49+x52+x28+(((-1.0)*x55))+(((-1.0)*x3*x55)));
eerot[3]=(((x50*x9))+x24);
eerot[4]=(((x11*(((((-1.0)*x0*x9))+x53))))+((x10*x51)));
eerot[5]=(((x11*x51))+((x10*((((x20*x50))+x26)))));
eetrans[1]=((((-1.0)*x31))+(((2.0)*x24))+((x9*((((x17*x37))+((x16*x41))))))+x8+(((-1.0)*x26))+x50+x53+x29+((x3*x8)));
eerot[6]=(x46*x9);
eerot[7]=(((x10*x47))+((x11*x48)));
eerot[8]=(((x11*x47))+((x10*x7*(((((-1.0)*x13*x32))+(((-1.0)*x15*x33)))))));
eetrans[2]=((1.0)+((x9*((((x17*x32))+((x16*x33))))))+x1+x32+x48+x46);
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((((-2.0)*r00))+px);
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((((-2.0)*r10))+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-1.0)+(((-2.0)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x56=((1.0)*px);
IkReal x57=((1.0)*pz);
IkReal x58=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x58))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x57)));
rxp0_2=((((-1.0)*r10*x56))+((py*r00)));
rxp1_0=((((-1.0)*r21*x58))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x57)));
rxp1_2=((((-1.0)*r11*x56))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x58)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x57)));
rxp2_2=((((-1.0)*r12*x56))+((py*r02)));
{
IkReal j0eval[1];
IkReal x59=px*px;
IkReal x60=r02*r02;
IkReal x61=((((4.0)*px*py))+(((4.0)*r02*r12)));
j0eval[0]=((IKabs(((-2.0)+(((4.0)*(py*py)))+(((-2.0)*x60))+(((-2.0)*x59))+(((4.0)*(r12*r12))))))+(((2.0)*(IKabs(x61))))+(IKabs(((-1.0)+x59+x60))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal x62=r02*r02;
IkReal x63=px*px;
IkReal x64=((-1.0)+x62+x63);
IkReal x65=((((4.0)*px*py))+(((4.0)*r02*r12)));
op[0]=x64;
op[1]=((-1.0)*x65);
op[2]=((-2.0)+(((4.0)*(py*py)))+(((-2.0)*x62))+(((-2.0)*x63))+(((4.0)*(r12*r12))));
op[3]=x65;
op[4]=x64;
polyroots4(op,zeror,numroots);
IkReal j0array[4], cj0array[4], sj0array[4], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[4]={true,true,true,true};
_nj0 = 4;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
IkReal op[2+1], zeror[2];
int numroots;
IkReal j2evalpoly[1];
op[0]=((((16.0)*npz*pz*r22*rxp2_1*sj0))+(((16.0)*npz*pz*(r02*r02)*(sj0*sj0)))+(((16.0)*r02*r12*rxp2_0*sj0*(cj0*cj0)))+(((-8.0)*(r22*r22*r22)))+(((16.0)*px*r12*rxp2_0*(cj0*cj0*cj0)))+(((16.0)*npz*pz*(cj0*cj0)*(r12*r12)))+(((16.0)*px*r12*r22*(cj0*cj0)))+(((-16.0)*cj0*npz*r22*sj0*(px*px)))+(((-16.0)*cj0*npz*px*r12*rxp2_1*(sj0*sj0)))+(((16.0)*pz*r02*sj0*(npz*npz)))+(((-8.0)*rxp2_1*sj0*(cj0*cj0)*(r12*r12)))+(((-8.0)*pp*(r22*r22*r22)))+(((16.0)*npz*pz*(r22*r22)))+(((-16.0)*cj0*px*r02*r22*sj0))+(((-16.0)*npz*py*r02*rxp2_0*sj0*(cj0*cj0)))+(((-8.0)*rxp2_0*(cj0*cj0*cj0)*(r12*r12)))+(((-16.0)*npz*px*py*r22*(sj0*sj0)))+(((-24.0)*cj0*rxp2_0*(r22*r22)))+(((-8.0)*cj0*pp*rxp2_0*(r02*r02)*(sj0*sj0)))+(((-8.0)*pp*rxp2_1*sj0*(r22*r22)))+(((-16.0)*npz*px*pz*r12*(cj0*cj0)))+(((16.0)*cj0*r02*r12*rxp2_1*(sj0*sj0)))+(((16.0)*npz*px*r02*rxp2_1*(sj0*sj0*sj0)))+(((-16.0)*r22*(npz*npz)))+(((-16.0)*cj0*npz*py*pz*r12*sj0))+(((-32.0)*cj0*r22*rxp2_0*rxp2_1*sj0))+(((-16.0)*cj0*npz*px*r22))+(((-8.0)*pp*r22*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*py*r22*(npz*npz)))+(((16.0)*cj0*npz*px*r02*rxp2_0*(sj0*sj0)))+(((-16.0)*cj0*pz*r12*(npz*npz)))+(((-8.0)*pp*rxp2_1*sj0*(cj0*cj0)*(r12*r12)))+(((16.0)*cj0*npz*r12*r22))+(((-8.0)*r22*(cj0*cj0)*(r12*r12)))+(((-16.0)*px*r02*rxp2_0*sj0*(cj0*cj0)))+(((-16.0)*px*r22*sj0*(npz*npz)))+(((16.0)*cj0*pp*r02*r12*rxp2_1*(sj0*sj0)))+(((16.0)*npz*py*r12*rxp2_0*(cj0*cj0*cj0)))+(((16.0)*npz*py*pz*r02*(sj0*sj0)))+(((16.0)*pp*r02*r12*rxp2_0*sj0*(cj0*cj0)))+(((16.0)*cj0*npz*r22*sj0*(py*py)))+(((16.0)*cj0*py*r12*rxp2_1*(sj0*sj0)))+(((-16.0)*py*r02*r22*(sj0*sj0)))+(((-8.0)*pp*rxp2_1*(r02*r02)*(sj0*sj0*sj0)))+(((16.0)*cj0*pp*r02*r12*r22*sj0))+(((16.0)*px*r12*rxp2_1*sj0*(cj0*cj0)))+(((-16.0)*cj0*px*r02*rxp2_1*(sj0*sj0)))+(((-16.0)*npz*px*r12*rxp2_0*sj0*(cj0*cj0)))+(((-8.0)*cj0*pp*rxp2_0*(r22*r22)))+(((16.0)*npz*px*py*r22*(cj0*cj0)))+(((-24.0)*rxp2_1*sj0*(r22*r22)))+(((16.0)*cj0*py*r12*r22*sj0))+(((-32.0)*cj0*npz*pz*r02*r12*sj0))+(((-16.0)*npz*r02*r22*sj0))+(((-16.0)*cj0*py*r02*rxp2_0*(sj0*sj0)))+(((16.0)*cj0*npz*pz*r22*rxp2_0))+(((-8.0)*pp*r22*(cj0*cj0)*(r12*r12)))+(((-8.0)*r22*(r02*r02)*(sj0*sj0)))+(((16.0)*npz*py*r12*rxp2_1*sj0*(cj0*cj0)))+(((-8.0)*rxp2_1*(r02*r02)*(sj0*sj0*sj0)))+(((16.0)*py*r12*rxp2_0*sj0*(cj0*cj0)))+(((-16.0)*r22*(rxp2_1*rxp2_1)*(sj0*sj0)))+(((-16.0)*npz*py*r22*sj0))+(((-8.0)*cj0*rxp2_0*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*r02*r12*r22*sj0))+(((16.0)*cj0*npz*px*pz*r02*sj0))+(((-16.0)*py*r02*rxp2_1*(sj0*sj0*sj0)))+(((-16.0)*r22*(cj0*cj0)*(rxp2_0*rxp2_0)))+(((-8.0)*pp*rxp2_0*(cj0*cj0*cj0)*(r12*r12)))+(((-16.0)*cj0*npz*py*r02*rxp2_1*(sj0*sj0))));
op[1]=0;
op[2]=((((24.0)*(r22*r22*r22)))+(((16.0)*npz*pz*r22*rxp2_1*sj0))+(((16.0)*npz*pz*(r02*r02)*(sj0*sj0)))+(((16.0)*px*r12*rxp2_0*(cj0*cj0*cj0)))+(((16.0)*npz*pz*(cj0*cj0)*(r12*r12)))+(((16.0)*px*r12*r22*(cj0*cj0)))+(((-16.0)*cj0*npz*r22*sj0*(px*px)))+(((-16.0)*cj0*npz*px*r12*rxp2_1*(sj0*sj0)))+(((16.0)*pz*r02*sj0*(npz*npz)))+(((-8.0)*pp*(r22*r22*r22)))+(((16.0)*npz*pz*(r22*r22)))+(((24.0)*rxp2_1*(r02*r02)*(sj0*sj0*sj0)))+(((-16.0)*cj0*px*r02*r22*sj0))+(((-16.0)*npz*py*r02*rxp2_0*sj0*(cj0*cj0)))+(((-16.0)*npz*px*py*r22*(sj0*sj0)))+(((24.0)*cj0*rxp2_0*(r02*r02)*(sj0*sj0)))+(((8.0)*cj0*rxp2_0*(r22*r22)))+(((-8.0)*cj0*pp*rxp2_0*(r02*r02)*(sj0*sj0)))+(((-8.0)*pp*rxp2_1*sj0*(r22*r22)))+(((-16.0)*npz*px*pz*r12*(cj0*cj0)))+(((16.0)*npz*px*r02*rxp2_1*(sj0*sj0*sj0)))+(((-16.0)*r22*(npz*npz)))+(((-16.0)*cj0*npz*py*pz*r12*sj0))+(((-32.0)*cj0*r22*rxp2_0*rxp2_1*sj0))+(((-16.0)*cj0*npz*px*r22))+(((24.0)*rxp2_1*sj0*(cj0*cj0)*(r12*r12)))+(((-48.0)*cj0*r02*r12*rxp2_1*(sj0*sj0)))+(((-8.0)*pp*r22*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*py*r22*(npz*npz)))+(((16.0)*cj0*npz*px*r02*rxp2_0*(sj0*sj0)))+(((-16.0)*cj0*pz*r12*(npz*npz)))+(((-8.0)*pp*rxp2_1*sj0*(cj0*cj0)*(r12*r12)))+(((16.0)*cj0*npz*r12*r22))+(((-16.0)*px*r02*rxp2_0*sj0*(cj0*cj0)))+(((-16.0)*px*r22*sj0*(npz*npz)))+(((16.0)*cj0*pp*r02*r12*rxp2_1*(sj0*sj0)))+(((16.0)*npz*py*r12*rxp2_0*(cj0*cj0*cj0)))+(((16.0)*npz*py*pz*r02*(sj0*sj0)))+(((16.0)*pp*r02*r12*rxp2_0*sj0*(cj0*cj0)))+(((16.0)*cj0*npz*r22*sj0*(py*py)))+(((8.0)*rxp2_1*sj0*(r22*r22)))+(((24.0)*r22*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*py*r12*rxp2_1*(sj0*sj0)))+(((-16.0)*py*r02*r22*(sj0*sj0)))+(((-8.0)*pp*rxp2_1*(r02*r02)*(sj0*sj0*sj0)))+(((16.0)*cj0*pp*r02*r12*r22*sj0))+(((16.0)*px*r12*rxp2_1*sj0*(cj0*cj0)))+(((-16.0)*cj0*px*r02*rxp2_1*(sj0*sj0)))+(((-16.0)*npz*px*r12*rxp2_0*sj0*(cj0*cj0)))+(((24.0)*rxp2_0*(cj0*cj0*cj0)*(r12*r12)))+(((-8.0)*cj0*pp*rxp2_0*(r22*r22)))+(((16.0)*npz*px*py*r22*(cj0*cj0)))+(((16.0)*cj0*py*r12*r22*sj0))+(((-32.0)*cj0*npz*pz*r02*r12*sj0))+(((-16.0)*npz*r02*r22*sj0))+(((-16.0)*cj0*py*r02*rxp2_0*(sj0*sj0)))+(((16.0)*cj0*npz*pz*r22*rxp2_0))+(((-8.0)*pp*r22*(cj0*cj0)*(r12*r12)))+(((16.0)*npz*py*r12*rxp2_1*sj0*(cj0*cj0)))+(((16.0)*py*r12*rxp2_0*sj0*(cj0*cj0)))+(((-16.0)*r22*(rxp2_1*rxp2_1)*(sj0*sj0)))+(((-16.0)*npz*py*r22*sj0))+(((-48.0)*r02*r12*rxp2_0*sj0*(cj0*cj0)))+(((24.0)*r22*(cj0*cj0)*(r12*r12)))+(((16.0)*cj0*npz*px*pz*r02*sj0))+(((-16.0)*py*r02*rxp2_1*(sj0*sj0*sj0)))+(((-16.0)*r22*(cj0*cj0)*(rxp2_0*rxp2_0)))+(((-8.0)*pp*rxp2_0*(cj0*cj0*cj0)*(r12*r12)))+(((-48.0)*cj0*r02*r12*r22*sj0))+(((-16.0)*cj0*npz*py*r02*rxp2_1*(sj0*sj0))));
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

j2evalpoly[0]=((((24.0)*(cj0*cj0*cj0)*(r12*r12*r12)))+(((24.0)*cj0*px*(r22*r22)))+(((-16.0)*cj0*npz*py*r12*sj0))+(((-16.0)*cj0*npz*px*py*r12*(sj0*sj0)))+(((16.0)*npz*px*r22*rxp2_1*(sj0*sj0)))+(((-8.0)*cj0*pp*px*(r22*r22)))+(((-24.0)*(r02*r02*r02)*(sj0*sj0*sj0)))+(((-16.0)*npz*r12*sj0*(cj0*cj0)*(px*px)))+(((-8.0)*npz*(r02*r02)*(sj0*sj0)))+(((-16.0)*cj0*npz*py*(r22*r22)))+(((16.0)*r02*sj0*(npz*npz)))+(((16.0)*cj0*npz*px*pz*r22))+(((-16.0)*r12*(cj0*cj0*cj0)*(rxp2_0*rxp2_0)))+(((16.0)*r02*(rxp2_1*rxp2_1)*(sj0*sj0*sj0)))+(((-16.0)*cj0*py*r22*rxp2_0*sj0))+(((-16.0)*cj0*r12*r22*rxp2_1*sj0))+(((16.0)*cj0*npz*r02*(px*px)*(sj0*sj0)))+(((16.0)*cj0*npz*px*r22*rxp2_0*sj0))+(((16.0)*npz*px*sj0*(r22*r22)))+(((-16.0)*npz*py*(cj0*cj0*cj0)*(r12*r12)))+(((-8.0)*npz*pp*(cj0*cj0)*(r12*r12)))+(((-8.0)*pp*py*sj0*(cj0*cj0)*(r12*r12)))+(((-16.0)*r12*r22*rxp2_0*(cj0*cj0)))+(((40.0)*py*sj0*(cj0*cj0)*(r12*r12)))+(((-8.0)*cj0*pp*px*(r02*r02)*(sj0*sj0)))+(((-24.0)*pp*r02*sj0*(cj0*cj0)*(r12*r12)))+(((-32.0)*cj0*npz*px*r02*r12*(sj0*sj0)))+(((16.0)*pz*r22*(npz*npz)))+(((-8.0)*npz*(cj0*cj0)*(r12*r12)))+(((16.0)*px*r02*(npz*npz)*(sj0*sj0)))+(((-16.0)*cj0*npz*py*r22*rxp2_1*sj0))+(((-8.0)*pp*r02*sj0*(r22*r22)))+(((40.0)*px*(cj0*cj0*cj0)*(r12*r12)))+(((-16.0)*cj0*px*r22*rxp2_1*sj0))+(((24.0)*py*sj0*(r22*r22)))+(((-16.0)*cj0*px*r12*sj0*(npz*npz)))+(((16.0)*py*r12*(cj0*cj0)*(npz*npz)))+(((8.0)*cj0*pp*r12*(r22*r22)))+(((16.0)*pp*px*r02*r12*sj0*(cj0*cj0)))+(((40.0)*cj0*px*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*pp*py*r02*r12*(sj0*sj0)))+(((16.0)*npz*px*(r02*r02)*(sj0*sj0*sj0)))+(((16.0)*cj0*npz*pp*r02*r12*sj0))+(((-8.0)*pp*py*sj0*(r22*r22)))+(((16.0)*r02*r22*rxp2_1*(sj0*sj0)))+(((-16.0)*npz*py*r22*rxp2_0*(cj0*cj0)))+(((-72.0)*r02*sj0*(cj0*cj0)*(r12*r12)))+(((-16.0)*cj0*npz*py*(r02*r02)*(sj0*sj0)))+(((16.0)*npz*px*py*r02*(sj0*sj0*sj0)))+(((32.0)*npz*py*r02*r12*sj0*(cj0*cj0)))+(((16.0)*npz*px*sj0*(cj0*cj0)*(r12*r12)))+(((-8.0)*pp*py*(r02*r02)*(sj0*sj0*sj0)))+(((16.0)*npz*py*pz*r22*sj0))+(((-24.0)*r02*sj0*(r22*r22)))+(((16.0)*cj0*npz*pz*r12*rxp2_1*sj0))+(((8.0)*pp*(cj0*cj0*cj0)*(r12*r12*r12)))+(((72.0)*cj0*r12*(r02*r02)*(sj0*sj0)))+(((-16.0)*npz*pz*r02*rxp2_1*(sj0*sj0)))+(((16.0)*npz*px*py*r12*(cj0*cj0*cj0)))+(((-16.0)*cj0*r12*(rxp2_1*rxp2_1)*(sj0*sj0)))+(((16.0)*cj0*npz*px*r02*sj0))+(((-16.0)*cj0*npz*pz*r02*rxp2_0*sj0))+(((-16.0)*npz*px*py*r02*sj0*(cj0*cj0)))+(((-16.0)*cj0*r12*(npz*npz)))+(((40.0)*py*(r02*r02)*(sj0*sj0*sj0)))+(((-24.0)*npz*(r22*r22)))+(((-8.0)*pp*px*(cj0*cj0*cj0)*(r12*r12)))+(((16.0)*npz*pz*r12*rxp2_0*(cj0*cj0)))+(((16.0)*npz*py*r02*(sj0*sj0)))+(((16.0)*cj0*npz*r02*r12*sj0))+(((-16.0)*cj0*py*r02*sj0*(npz*npz)))+(((16.0)*r02*sj0*(cj0*cj0)*(rxp2_0*rxp2_0)))+(((-16.0)*py*r22*rxp2_1*(sj0*sj0)))+(((24.0)*cj0*r12*(r22*r22)))+(((-16.0)*px*r22*rxp2_0*(cj0*cj0)))+(((32.0)*cj0*r02*rxp2_0*rxp2_1*(sj0*sj0)))+(((-80.0)*cj0*py*r02*r12*(sj0*sj0)))+(((-8.0)*pp*(r02*r02*r02)*(sj0*sj0*sj0)))+(((-80.0)*px*r02*r12*sj0*(cj0*cj0)))+(((-16.0)*npz*px*r12*(cj0*cj0)))+(((-8.0)*npz*pp*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*r02*r22*rxp2_0*sj0))+(((htj2*htj2)*(((((-16.0)*cj0*py*r02*r12*(sj0*sj0)))+(((8.0)*cj0*px*(r02*r02)*(sj0*sj0)))+(((8.0)*r02*sj0*(r22*r22)))+(((-16.0)*cj0*npz*py*r12*sj0))+(((-16.0)*cj0*npz*px*py*r12*(sj0*sj0)))+(((16.0)*npz*px*r22*rxp2_1*(sj0*sj0)))+(((-8.0)*cj0*pp*px*(r22*r22)))+(((-16.0)*npz*r12*sj0*(cj0*cj0)*(px*px)))+(((8.0)*npz*(r22*r22)))+(((-16.0)*px*r02*r12*sj0*(cj0*cj0)))+(((-16.0)*cj0*npz*py*(r22*r22)))+(((16.0)*r02*sj0*(npz*npz)))+(((-8.0)*cj0*px*(r22*r22)))+(((16.0)*cj0*npz*px*pz*r22))+(((-16.0)*r12*(cj0*cj0*cj0)*(rxp2_0*rxp2_0)))+(((16.0)*r02*(rxp2_1*rxp2_1)*(sj0*sj0*sj0)))+(((-16.0)*cj0*py*r22*rxp2_0*sj0))+(((-16.0)*cj0*r12*r22*rxp2_1*sj0))+(((16.0)*cj0*npz*r02*(px*px)*(sj0*sj0)))+(((16.0)*cj0*npz*px*r22*rxp2_0*sj0))+(((16.0)*npz*px*sj0*(r22*r22)))+(((-16.0)*npz*py*(cj0*cj0*cj0)*(r12*r12)))+(((8.0)*(r02*r02*r02)*(sj0*sj0*sj0)))+(((8.0)*px*(cj0*cj0*cj0)*(r12*r12)))+(((-8.0)*(cj0*cj0*cj0)*(r12*r12*r12)))+(((-8.0)*py*sj0*(r22*r22)))+(((-8.0)*npz*pp*(cj0*cj0)*(r12*r12)))+(((-8.0)*pp*py*sj0*(cj0*cj0)*(r12*r12)))+(((8.0)*py*(r02*r02)*(sj0*sj0*sj0)))+(((-16.0)*r12*r22*rxp2_0*(cj0*cj0)))+(((-8.0)*cj0*pp*px*(r02*r02)*(sj0*sj0)))+(((-24.0)*pp*r02*sj0*(cj0*cj0)*(r12*r12)))+(((-32.0)*cj0*npz*px*r02*r12*(sj0*sj0)))+(((16.0)*pz*r22*(npz*npz)))+(((16.0)*px*r02*(npz*npz)*(sj0*sj0)))+(((-16.0)*cj0*npz*py*r22*rxp2_1*sj0))+(((-8.0)*pp*r02*sj0*(r22*r22)))+(((-48.0)*cj0*npz*r02*r12*sj0))+(((-16.0)*cj0*px*r22*rxp2_1*sj0))+(((-16.0)*cj0*px*r12*sj0*(npz*npz)))+(((16.0)*py*r12*(cj0*cj0)*(npz*npz)))+(((8.0)*cj0*pp*r12*(r22*r22)))+(((8.0)*py*sj0*(cj0*cj0)*(r12*r12)))+(((16.0)*pp*px*r02*r12*sj0*(cj0*cj0)))+(((24.0)*npz*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*pp*py*r02*r12*(sj0*sj0)))+(((16.0)*npz*px*(r02*r02)*(sj0*sj0*sj0)))+(((16.0)*cj0*npz*pp*r02*r12*sj0))+(((-8.0)*pp*py*sj0*(r22*r22)))+(((16.0)*r02*r22*rxp2_1*(sj0*sj0)))+(((-16.0)*npz*py*r22*rxp2_0*(cj0*cj0)))+(((-24.0)*cj0*r12*(r02*r02)*(sj0*sj0)))+(((-16.0)*cj0*npz*py*(r02*r02)*(sj0*sj0)))+(((16.0)*npz*px*py*r02*(sj0*sj0*sj0)))+(((32.0)*npz*py*r02*r12*sj0*(cj0*cj0)))+(((16.0)*npz*px*sj0*(cj0*cj0)*(r12*r12)))+(((-8.0)*pp*py*(r02*r02)*(sj0*sj0*sj0)))+(((16.0)*npz*py*pz*r22*sj0))+(((16.0)*cj0*npz*pz*r12*rxp2_1*sj0))+(((8.0)*pp*(cj0*cj0*cj0)*(r12*r12*r12)))+(((-16.0)*npz*pz*r02*rxp2_1*(sj0*sj0)))+(((16.0)*npz*px*py*r12*(cj0*cj0*cj0)))+(((-16.0)*cj0*r12*(rxp2_1*rxp2_1)*(sj0*sj0)))+(((16.0)*cj0*npz*px*r02*sj0))+(((-16.0)*cj0*npz*pz*r02*rxp2_0*sj0))+(((-16.0)*npz*px*py*r02*sj0*(cj0*cj0)))+(((24.0)*npz*(cj0*cj0)*(r12*r12)))+(((-16.0)*cj0*r12*(npz*npz)))+(((-8.0)*pp*px*(cj0*cj0*cj0)*(r12*r12)))+(((16.0)*npz*pz*r12*rxp2_0*(cj0*cj0)))+(((16.0)*npz*py*r02*(sj0*sj0)))+(((-16.0)*cj0*py*r02*sj0*(npz*npz)))+(((16.0)*r02*sj0*(cj0*cj0)*(rxp2_0*rxp2_0)))+(((-16.0)*py*r22*rxp2_1*(sj0*sj0)))+(((-16.0)*px*r22*rxp2_0*(cj0*cj0)))+(((32.0)*cj0*r02*rxp2_0*rxp2_1*(sj0*sj0)))+(((-8.0)*pp*(r02*r02*r02)*(sj0*sj0*sj0)))+(((-16.0)*npz*px*r12*(cj0*cj0)))+(((-8.0)*npz*pp*(r02*r02)*(sj0*sj0)))+(((16.0)*cj0*r02*r22*rxp2_0*sj0))+(((24.0)*r02*sj0*(cj0*cj0)*(r12*r12)))+(((16.0)*npz*r12*sj0*(cj0*cj0)*(py*py)))+(((-32.0)*r12*rxp2_0*rxp2_1*sj0*(cj0*cj0)))+(((-8.0)*npz*pp*(r22*r22)))+(((24.0)*cj0*pp*r12*(r02*r02)*(sj0*sj0)))+(((-8.0)*cj0*r12*(r22*r22)))+(((-16.0)*cj0*npz*r02*(py*py)*(sj0*sj0)))))))+(((16.0)*npz*r12*sj0*(cj0*cj0)*(py*py)))+(((-32.0)*r12*rxp2_0*rxp2_1*sj0*(cj0*cj0)))+(((-8.0)*npz*pp*(r22*r22)))+(((24.0)*cj0*pp*r12*(r02*r02)*(sj0*sj0)))+(((-16.0)*cj0*npz*r02*(py*py)*(sj0*sj0))));
if( IKabs(j2evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((-1.0)*py*sj0))+(((-1.0)*cj0*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r12*sj0))+((cj0*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))))+IKsqr((((r12*sj0))+((cj0*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))), (((r12*sj0))+((cj0*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x66=((1.0)*sj0);
IkReal x67=((1.0)*cj0);
evalcond[0]=((((-1.0)*r02*x67))+(IKcos(j4))+(((-1.0)*r12*x66)));
evalcond[1]=((((-1.0)*px*x67))+(((-1.0)*(IKsin(j4))))+(((-1.0)*py*x66)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x68=sj4*sj4;
IkReal x69=(npz*sj4);
IkReal x70=((32.0)*sj4);
IkReal x71=(cj0*r12);
IkReal x72=(cj2*sj4);
IkReal x73=((16.0)*sj0);
IkReal x74=((16.0)*cj4);
IkReal x75=((16.0)*sj4);
IkReal x76=(r02*sj4);
IkReal x77=((16.0)*cj2);
IkReal x78=(r02*sj0);
IkReal x79=(cj2*sj2);
IkReal x80=((8.0)*cj2);
IkReal x81=(cj4*r22);
IkReal x82=((8.0)*cj4);
IkReal x83=((24.0)*x69);
IkReal x84=((4.0)*x68);
IkReal x85=(px*x68);
IkReal x86=((12.0)*x68);
IkReal x87=(pz*x68);
IkReal x88=(cj4*x83);
IkReal x89=(pp*x86);
IkReal x90=((4.0)*r22*x72);
IkReal x91=(cj0*py*x68);
IkReal x92=(cj2*pz*x84);
IkReal x93=(x79*x86);
IkReal x94=((4.0)*x72*x81);
IkReal x95=(x88+x83);
IkReal x96=(x90+x94);
j1eval[0]=((((0.5)*(IKabs((x93+x96+(((-1.0)*x92)))))))+(((0.5)*(IKabs(((((16.0)*x91))+(((-1.0)*x73*x85))+((cj4*x73*x76))+x95+(((-1.0)*x71*x75))+((x73*x76))+(((-1.0)*x89))+(((-1.0)*x84))+(((-1.0)*sj4*x71*x74)))))))+(((0.5)*(IKabs(((((-1.0)*cj4*x70*x71))+(((-1.0)*x70*x71))+(((32.0)*x91))+x95+(((-32.0)*sj0*x85))+(((-20.0)*x68))+((x70*x78))+(((-1.0)*x89))+((cj4*x70*x78)))))))+(IKabs(((((-1.0)*r22*x75))+(((16.0)*x87))+(((-1.0)*r22*sj4*x74)))))+(((0.5)*(IKabs((x93+x92+(((-1.0)*x96)))))))+(((0.5)*(IKabs(((((-1.0)*r22*x70))+(((-1.0)*x70*x81))+(((32.0)*x87)))))))+(((0.5)*(IKabs(((((-16.0)*x71*x72))+((cj4*r02*x72*x73))+((r02*x72*x73))+(((-1.0)*cj2*x73*x85))+(((-1.0)*x71*x72*x74))+(((-1.0)*x68*x77))+((x77*x91)))))))+(IKabs(((((-8.0)*x71*x72))+((x72*x78*x82))+(((-1.0)*x68*x80))+(((8.0)*x72*x78))+((x80*x91))+(((-1.0)*x71*x72*x82))+(((-1.0)*sj0*x80*x85)))))+(((0.5)*(IKabs((((x79*x84))+x92+(((-1.0)*x96)))))))+(((0.5)*(IKabs((((x69*x82))+(((8.0)*x69))+x84+(((-1.0)*pp*x84))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j3, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x97=sj4*sj4;
IkReal x98=(npz*sj4);
IkReal x99=((32.0)*sj4);
IkReal x100=(cj0*r12);
IkReal x101=((16.0)*sj0);
IkReal x102=(r02*sj4);
IkReal x103=(cj0*py);
IkReal x104=(r02*sj0);
IkReal x105=(cj4*r22);
IkReal x106=((16.0)*sj4);
IkReal x107=((4.0)*x97);
IkReal x108=((24.0)*x98);
IkReal x109=((8.0)*x98);
IkReal x110=(px*x97);
IkReal x111=((32.0)*x97);
IkReal x112=((12.0)*x97);
IkReal x113=((16.0)*x97);
IkReal x114=(cj4*x108);
IkReal x115=(pp*x112);
IkReal x116=(x101*x102);
IkReal x117=(cj4*x109);
IkReal x118=(pp*x107);
IkReal x119=(x100*x106);
IkReal x120=(x103*x113);
IkReal x121=(cj4*x116);
IkReal x122=(x101*x110);
IkReal x123=(cj4*x119);
IkReal x124=(x114+x108);
IkReal x125=(x117+x109);
IkReal x126=(((pz*x113))+(((-1.0)*r22*x106))+(((-1.0)*x105*x106)));
IkReal x127=(x120+x121+x116);
IkReal x128=(x122+x123+x119);
op[0]=((((-1.0)*x118))+x125+x107);
op[1]=x126;
op[2]=((((-1.0)*x107))+(((-1.0)*x115))+(((-1.0)*x128))+x127+x124);
op[3]=(((pz*x111))+(((-1.0)*x105*x99))+(((-1.0)*r22*x99)));
op[4]=((((-1.0)*x115))+((x103*x111))+x124+((cj4*x104*x99))+(((-20.0)*x97))+(((-1.0)*x100*x99))+(((-1.0)*cj4*x100*x99))+((x104*x99))+(((-32.0)*sj0*x110)));
op[5]=x126;
op[6]=((((-1.0)*x112))+(((-1.0)*x118))+(((-1.0)*x128))+x127+x125);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x129=sj4*sj4;
IkReal x130=((8.0)*cj0);
IkReal x131=((16.0)*cj0);
IkReal x132=(px*sj0);
IkReal x133=(cj2*x129);
IkReal x134=(cj2*r12*sj4);
IkReal x135=((4.0)*cj2*r22*sj4);
IkReal x136=(cj2*r02*sj0*sj4);
IkReal x137=(cj4*x135);
IkReal x138=((12.0)*sj2*x133);
IkReal x139=((4.0)*pz*x133);
IkReal x140=((4.0)*sj2*x133);
IkReal x141=(x135+x137);
IkReal x142=(((py*x130*x133))+(((-8.0)*x132*x133))+(((-8.0)*x133))+(((8.0)*cj4*x136))+(((-1.0)*cj4*x130*x134))+(((-1.0)*x130*x134))+(((8.0)*x136)));
j1evalpoly[0]=((((htj1*htj1*htj1)*(((((16.0)*x136))+(((-16.0)*x132*x133))+(((-1.0)*cj4*x131*x134))+((py*x131*x133))+(((16.0)*cj4*x136))+(((-1.0)*x131*x134))+(((-16.0)*x133))))))+(((htj1*htj1)*((x141+x138+(((-1.0)*x139))))))+((x142*(htj1*htj1*htj1*htj1*htj1)))+x140+x141+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x141))+x139+x138))))+(((-1.0)*x139))+((htj1*x142))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x141))+x140+x139)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j3eval[2];
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=sj4;
j3eval[1]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=sj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x143=((1.0)*sj1);
IkReal x144=(cj0*r12);
IkReal x145=(r02*sj0);
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
j3eval[2]=((IKabs(((((-1.0)*cj1*x144))+((cj1*x145))+(((-1.0)*r22*x143)))))+(IKabs(((((-1.0)*x143*x144))+((sj1*x145))+((cj1*r22))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x146=(r02*sj0);
IkReal x147=(cj1*x146);
IkReal x148=((1.0)*r22*sj1);
IkReal x149=((1.0)*cj0*r12);
IkReal x150=(cj1*x149);
IkReal x151=(x150+x148);
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
j3eval[2]=((IKabs(((((-1.0)*x149))+(((-1.0)*x151))+(((-1.0)*sj4))+npz+x146+x147)))+(IKabs(((((-1.0)*x151))+x147))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j3eval[0]=((-1.0)+(((-1.0)*cj4)));
j3eval[1]=sj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x152=((0.5)*sj1);
IkReal x153=((0.5)*cj1);
IkReal x154=(cj0*py);
IkReal x155=(px*sj0);
if( IKabs(((0.5)+((x153*x155))+(((-1.0)*x153*x154))+(((-1.0)*pz*x152))+x153)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.5)+((x152*x155))+x152+(((-1.0)*x152*x154))+((pz*x153)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.5)+((x153*x155))+(((-1.0)*x153*x154))+(((-1.0)*pz*x152))+x153))+IKsqr(((-0.5)+((x152*x155))+x152+(((-1.0)*x152*x154))+((pz*x153))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.5)+((x153*x155))+(((-1.0)*x153*x154))+(((-1.0)*pz*x152))+x153), ((-0.5)+((x152*x155))+x152+(((-1.0)*x152*x154))+((pz*x153))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x156=IKcos(j3);
CheckValue<IkReal> x176=IKPowWithIntegerCheck(px,-1);
if(!x176.valid){
continue;
}
IkReal x157=x176.value;
IkReal x158=((2.0)*cj1);
IkReal x159=((1.0)*pp);
IkReal x160=(cj1*rxp2_2);
IkReal x161=(cj1*sj0);
IkReal x162=(cj0*cj1);
IkReal x163=((2.0)*py);
IkReal x164=(pz*sj1);
IkReal x165=(px*sj0);
IkReal x166=(sj0*sj1);
IkReal x167=((1.0)*py);
IkReal x168=(cj0*sj1);
IkReal x169=((2.0)*(IKsin(j3)));
IkReal x170=((2.0)*x156);
IkReal x171=((4.0)*x156);
IkReal x172=((2.0)*x166);
IkReal x173=(py*rxp2_1*x157);
IkReal x174=((3.0)+x171);
IkReal x175=(x159+x158);
evalcond[0]=((-1.0)+sj1+((sj1*x165))+(((-1.0)*x170))+((cj1*pz))+(((-1.0)*x167*x168)));
evalcond[1]=((1.0)+(((-1.0)*x169))+cj1+(((-1.0)*x164))+(((-1.0)*x162*x167))+((px*x161)));
evalcond[2]=((-1.0)+((rxp2_0*x166))+x169+x160+((x166*x173))+(((-1.0)*cj1)));
evalcond[3]=((-1.0)+(((-1.0)*x170))+((rxp2_0*x161))+(((-1.0)*rxp2_1*x162))+(((-1.0)*rxp2_2*sj1))+((r12*x166))+((r02*x168)));
evalcond[4]=(((rxp2_2*x158))+(((-1.0)*x175))+((rxp2_0*x172))+x174+((rxp2_1*x157*x163*x166))+(((2.0)*rxp2_2)));
evalcond[5]=(((cj0*x163))+(((-1.0)*x158*x165))+((cj0*py*x158))+(((-1.0)*x175))+x174+(((-2.0)*x165))+(((2.0)*x164)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x177=((1.0)*cj1);
CheckValue<IkReal> x178=IKPowWithIntegerCheck(((-1.0)+(((-1.0)*cj4))),-1);
if(!x178.valid){
continue;
}
CheckValue<IkReal> x179=IKPowWithIntegerCheck(sj4,-1);
if(!x179.valid){
continue;
}
if( IKabs(((x178.value)*(((-1.0)+(((-1.0)*x177))+(((-1.0)*px*sj0*x177))+((cj0*cj1*py))+((pz*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x179.value)*((((r02*sj0*sj1))+((cj1*r22))+(((-1.0)*cj0*r12*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x178.value)*(((-1.0)+(((-1.0)*x177))+(((-1.0)*px*sj0*x177))+((cj0*cj1*py))+((pz*sj1))))))+IKsqr(((x179.value)*((((r02*sj0*sj1))+((cj1*r22))+(((-1.0)*cj0*r12*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((x178.value)*(((-1.0)+(((-1.0)*x177))+(((-1.0)*px*sj0*x177))+((cj0*cj1*py))+((pz*sj1))))), ((x179.value)*((((r02*sj0*sj1))+((cj1*r22))+(((-1.0)*cj0*r12*sj1))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x180=IKcos(j3);
IkReal x181=IKsin(j3);
CheckValue<IkReal> x219=IKPowWithIntegerCheck(px,-1);
if(!x219.valid){
continue;
}
IkReal x182=x219.value;
IkReal x183=((1.0)*cj4);
IkReal x184=((1.0)*cj0);
IkReal x185=(pp*r12);
IkReal x186=((2.0)*sj1);
IkReal x187=(npz*pz);
IkReal x188=(cj1*rxp2_2);
IkReal x189=((1.0)*cj1);
IkReal x190=(cj1*rxp2_1);
IkReal x191=((2.0)*cj0);
IkReal x192=(rxp2_0*sj0);
IkReal x193=((2.0)*sj4);
IkReal x194=((2.0)*r22);
IkReal x195=((2.0)*cj4);
IkReal x196=((1.0)*r22);
IkReal x197=(cj1*r22);
IkReal x198=(cj1*r12);
IkReal x199=(rxp2_1*sj0);
IkReal x200=((2.0)*cj1);
IkReal x201=(r02*sj0);
IkReal x202=(cj1*py);
IkReal x203=(px*sj0);
IkReal x204=((1.0)*sj1);
IkReal x205=(pp*sj1);
IkReal x206=(r12*sj1);
IkReal x207=((1.0)*x180);
IkReal x208=((2.0)*x180);
IkReal x209=(sj4*x180);
IkReal x210=(rxp2_1*sj4*x182);
IkReal x211=((1.0)*x181);
IkReal x212=(sj4*x211);
IkReal x213=(x180*x183);
IkReal x214=(x180*x195);
IkReal x215=(py*x182*x199);
IkReal x216=(x200*x203);
IkReal x217=(x214+x208);
IkReal x218=(x213+x207);
evalcond[0]=((((-1.0)*x184*x206))+((sj1*x201))+x197+(((-1.0)*sj4*x207)));
evalcond[1]=(((cj1*x201))+(((-1.0)*x184*x198))+(((-1.0)*sj1*x196))+(((-1.0)*x212)));
evalcond[2]=((-1.0)+sj1+((sj1*x203))+((cj1*pz))+(((-1.0)*py*sj1*x184))+(((-1.0)*x218)));
evalcond[3]=((1.0)+(((-1.0)*x184*x202))+((cj1*x203))+cj1+(((-1.0)*pz*x204))+(((-1.0)*x211))+(((-1.0)*x181*x183)));
evalcond[4]=((((-1.0)*x189*x201))+sj4+((cj0*x198))+((r22*sj1))+(((-1.0)*npz))+x209+(((-1.0)*x201))+((cj0*r12)));
evalcond[5]=((((-1.0)*x201*x204))+(((-1.0)*r22*x189))+(((-1.0)*x199))+(((-1.0)*x196))+((cj0*x206))+(((-1.0)*x212))+(((-1.0)*rxp2_0*x184)));
evalcond[6]=(((sj0*x206))+(((-1.0)*rxp2_2*x204))+(((-1.0)*x183))+(((-1.0)*x184*x190))+((cj1*x192))+(((-1.0)*x218))+((cj0*r02*sj1)));
evalcond[7]=(((sj1*x192))+(((-1.0)*x183))+x181+x188+((sj1*x215))+((sj1*x210))+(((-1.0)*cj1*x183))+((cj4*x181)));
evalcond[8]=((1.0)+((pz*x186))+x195+((x191*x202))+(((-1.0)*x200))+(((-1.0)*pp))+x217+(((-2.0)*x203))+(((-1.0)*x216))+((py*x191)));
evalcond[9]=((2.0)+(((-1.0)*pp*x183))+((x186*x192))+cj4+(((-1.0)*npz*x193))+x217+(((2.0)*rxp2_2))+((x186*x215))+((x186*x210))+(((2.0)*x188))+(((-1.0)*cj1*x195)));
evalcond[10]=((((-1.0)*x187*x200))+((x201*x205))+((cj0*npz*py*x186))+((rxp2_0*x191))+x193+x194+x209+((cj1*x194))+(((-1.0)*npz*x186))+(((-1.0)*npz*x186*x203))+((pp*x197))+(((2.0)*x199))+(((-1.0)*sj1*x184*x185))+(((2.0)*sj0*x190))+((cj1*rxp2_0*x191)));
evalcond[11]=(((x186*x187))+(((-1.0)*x200*x201))+(((-1.0)*cj1*x184*x185))+(((-1.0)*x186*x199))+(((-1.0)*npz*x216))+(((-1.0)*cj0*rxp2_0*x186))+(((-2.0)*x201))+(((-1.0)*npz*x200))+((x191*x198))+((r12*x191))+((cj1*pp*x201))+(((-2.0)*npz))+(((-1.0)*x212))+(((-1.0)*x196*x205))+((npz*x191*x202)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x220=(r02*sj0);
IkReal x221=(cj0*r12);
IkReal x222=((((-1.0)*cj1*x221))+((cj1*x220))+(((-1.0)*r22*sj1)));
CheckValue<IkReal> x223 = IKatan2WithCheck(IkReal(x222),IkReal(((((-1.0)*sj4))+npz+x220+x222+(((-1.0)*x221)))),IKFAST_ATAN2_MAGTHRESH);
if(!x223.valid){
continue;
}
CheckValue<IkReal> x224=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x224.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x223.value)+(((1.5707963267949)*(x224.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x225=IKcos(j3);
IkReal x226=IKsin(j3);
CheckValue<IkReal> x264=IKPowWithIntegerCheck(px,-1);
if(!x264.valid){
continue;
}
IkReal x227=x264.value;
IkReal x228=((1.0)*cj4);
IkReal x229=((1.0)*cj0);
IkReal x230=(pp*r12);
IkReal x231=((2.0)*sj1);
IkReal x232=(npz*pz);
IkReal x233=(cj1*rxp2_2);
IkReal x234=((1.0)*cj1);
IkReal x235=(cj1*rxp2_1);
IkReal x236=((2.0)*cj0);
IkReal x237=(rxp2_0*sj0);
IkReal x238=((2.0)*sj4);
IkReal x239=((2.0)*r22);
IkReal x240=((2.0)*cj4);
IkReal x241=((1.0)*r22);
IkReal x242=(cj1*r22);
IkReal x243=(cj1*r12);
IkReal x244=(rxp2_1*sj0);
IkReal x245=((2.0)*cj1);
IkReal x246=(r02*sj0);
IkReal x247=(cj1*py);
IkReal x248=(px*sj0);
IkReal x249=((1.0)*sj1);
IkReal x250=(pp*sj1);
IkReal x251=(r12*sj1);
IkReal x252=((1.0)*x225);
IkReal x253=((2.0)*x225);
IkReal x254=(sj4*x225);
IkReal x255=(rxp2_1*sj4*x227);
IkReal x256=((1.0)*x226);
IkReal x257=(sj4*x256);
IkReal x258=(x225*x228);
IkReal x259=(x225*x240);
IkReal x260=(py*x227*x244);
IkReal x261=(x245*x248);
IkReal x262=(x259+x253);
IkReal x263=(x258+x252);
evalcond[0]=((((-1.0)*x229*x251))+x242+(((-1.0)*sj4*x252))+((sj1*x246)));
evalcond[1]=((((-1.0)*sj1*x241))+(((-1.0)*x229*x243))+((cj1*x246))+(((-1.0)*x257)));
evalcond[2]=((-1.0)+sj1+(((-1.0)*py*sj1*x229))+((cj1*pz))+(((-1.0)*x263))+((sj1*x248)));
evalcond[3]=((1.0)+(((-1.0)*pz*x249))+cj1+(((-1.0)*x229*x247))+((cj1*x248))+(((-1.0)*x226*x228))+(((-1.0)*x256)));
evalcond[4]=(((cj0*x243))+sj4+(((-1.0)*x246))+((r22*sj1))+(((-1.0)*npz))+(((-1.0)*x234*x246))+x254+((cj0*r12)));
evalcond[5]=((((-1.0)*r22*x234))+(((-1.0)*rxp2_0*x229))+(((-1.0)*x244))+((cj0*x251))+(((-1.0)*x241))+(((-1.0)*x246*x249))+(((-1.0)*x257)));
evalcond[6]=(((cj1*x237))+((sj0*x251))+(((-1.0)*x229*x235))+(((-1.0)*x263))+(((-1.0)*rxp2_2*x249))+(((-1.0)*x228))+((cj0*r02*sj1)));
evalcond[7]=(((sj1*x237))+((sj1*x255))+x226+x233+(((-1.0)*cj1*x228))+((cj4*x226))+((sj1*x260))+(((-1.0)*x228)));
evalcond[8]=((1.0)+(((-2.0)*x248))+((x236*x247))+((pz*x231))+(((-1.0)*pp))+x262+x240+((py*x236))+(((-1.0)*x245))+(((-1.0)*x261)));
evalcond[9]=((2.0)+(((2.0)*x233))+cj4+(((-1.0)*cj1*x240))+(((-1.0)*pp*x228))+(((-1.0)*npz*x238))+x262+((x231*x260))+(((2.0)*rxp2_2))+((x231*x237))+((x231*x255)));
evalcond[10]=(((x246*x250))+((cj1*x239))+((rxp2_0*x236))+(((2.0)*x244))+(((-1.0)*sj1*x229*x230))+(((-1.0)*npz*x231))+(((-1.0)*x232*x245))+x254+x238+x239+((cj0*npz*py*x231))+(((-1.0)*npz*x231*x248))+(((2.0)*sj0*x235))+((pp*x242))+((cj1*rxp2_0*x236)));
evalcond[11]=((((-1.0)*npz*x261))+(((-1.0)*npz*x245))+(((-2.0)*x246))+(((-1.0)*x231*x244))+((x236*x243))+(((-1.0)*x241*x250))+((cj1*pp*x246))+(((-1.0)*cj0*rxp2_0*x231))+((npz*x236*x247))+(((-2.0)*npz))+(((-1.0)*x245*x246))+((x231*x232))+(((-1.0)*cj1*x229*x230))+((r12*x236))+(((-1.0)*x257)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x265=((1.0)*sj1);
IkReal x266=(cj0*r12);
IkReal x267=(r02*sj0);
CheckValue<IkReal> x268=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x268.valid){
continue;
}
CheckValue<IkReal> x269 = IKatan2WithCheck(IkReal((((cj1*x267))+(((-1.0)*r22*x265))+(((-1.0)*cj1*x266)))),IkReal((((cj1*r22))+(((-1.0)*x265*x266))+((sj1*x267)))),IKFAST_ATAN2_MAGTHRESH);
if(!x269.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x268.value)))+(x269.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x270=IKcos(j3);
IkReal x271=IKsin(j3);
CheckValue<IkReal> x309=IKPowWithIntegerCheck(px,-1);
if(!x309.valid){
continue;
}
IkReal x272=x309.value;
IkReal x273=((1.0)*cj4);
IkReal x274=((1.0)*cj0);
IkReal x275=(pp*r12);
IkReal x276=((2.0)*sj1);
IkReal x277=(npz*pz);
IkReal x278=(cj1*rxp2_2);
IkReal x279=((1.0)*cj1);
IkReal x280=(cj1*rxp2_1);
IkReal x281=((2.0)*cj0);
IkReal x282=(rxp2_0*sj0);
IkReal x283=((2.0)*sj4);
IkReal x284=((2.0)*r22);
IkReal x285=((2.0)*cj4);
IkReal x286=((1.0)*r22);
IkReal x287=(cj1*r22);
IkReal x288=(cj1*r12);
IkReal x289=(rxp2_1*sj0);
IkReal x290=((2.0)*cj1);
IkReal x291=(r02*sj0);
IkReal x292=(cj1*py);
IkReal x293=(px*sj0);
IkReal x294=((1.0)*sj1);
IkReal x295=(pp*sj1);
IkReal x296=(r12*sj1);
IkReal x297=((1.0)*x270);
IkReal x298=((2.0)*x270);
IkReal x299=(sj4*x270);
IkReal x300=(rxp2_1*sj4*x272);
IkReal x301=((1.0)*x271);
IkReal x302=(sj4*x301);
IkReal x303=(x270*x273);
IkReal x304=(x270*x285);
IkReal x305=(py*x272*x289);
IkReal x306=(x290*x293);
IkReal x307=(x304+x298);
IkReal x308=(x303+x297);
evalcond[0]=(((sj1*x291))+x287+(((-1.0)*x274*x296))+(((-1.0)*sj4*x297)));
evalcond[1]=((((-1.0)*sj1*x286))+((cj1*x291))+(((-1.0)*x302))+(((-1.0)*x274*x288)));
evalcond[2]=((-1.0)+sj1+((sj1*x293))+((cj1*pz))+(((-1.0)*x308))+(((-1.0)*py*sj1*x274)));
evalcond[3]=((1.0)+(((-1.0)*pz*x294))+cj1+(((-1.0)*x271*x273))+((cj1*x293))+(((-1.0)*x274*x292))+(((-1.0)*x301)));
evalcond[4]=((((-1.0)*x291))+sj4+((r22*sj1))+((cj0*x288))+(((-1.0)*npz))+(((-1.0)*x279*x291))+x299+((cj0*r12)));
evalcond[5]=((((-1.0)*x291*x294))+(((-1.0)*x289))+(((-1.0)*r22*x279))+(((-1.0)*x286))+((cj0*x296))+(((-1.0)*x302))+(((-1.0)*rxp2_0*x274)));
evalcond[6]=(((sj0*x296))+(((-1.0)*rxp2_2*x294))+(((-1.0)*x273))+((cj1*x282))+(((-1.0)*x308))+((cj0*r02*sj1))+(((-1.0)*x274*x280)));
evalcond[7]=(((cj4*x271))+(((-1.0)*cj1*x273))+x271+x278+(((-1.0)*x273))+((sj1*x282))+((sj1*x300))+((sj1*x305)));
evalcond[8]=((1.0)+((x281*x292))+(((-1.0)*x290))+x307+(((-1.0)*pp))+x285+(((-2.0)*x293))+((pz*x276))+(((-1.0)*x306))+((py*x281)));
evalcond[9]=((2.0)+(((-1.0)*npz*x283))+cj4+(((2.0)*x278))+x307+(((-1.0)*cj1*x285))+(((2.0)*rxp2_2))+(((-1.0)*pp*x273))+((x276*x300))+((x276*x305))+((x276*x282)));
evalcond[10]=(((x291*x295))+(((-1.0)*sj1*x274*x275))+((rxp2_0*x281))+((cj1*rxp2_0*x281))+(((-1.0)*npz*x276))+((cj0*npz*py*x276))+(((2.0)*sj0*x280))+x299+x284+x283+(((-1.0)*x277*x290))+(((-1.0)*npz*x276*x293))+(((2.0)*x289))+((pp*x287))+((cj1*x284)));
evalcond[11]=((((-1.0)*cj1*x274*x275))+(((-1.0)*x290*x291))+((npz*x281*x292))+(((-1.0)*x276*x289))+(((-1.0)*x286*x295))+(((-1.0)*cj0*rxp2_0*x276))+(((-1.0)*npz*x290))+((r12*x281))+(((-2.0)*x291))+(((-2.0)*npz))+((x276*x277))+(((-1.0)*npz*x306))+((cj1*pp*x291))+((x281*x288))+(((-1.0)*x302)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x310=(cj0*r12);
IkReal x311=((1.0)*r02*sj0);
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
j3eval[2]=((IKabs((((r22*sj1))+((cj1*x310))+(((-1.0)*cj1*x311)))))+(IKabs(((((-1.0)*sj1*x311))+((sj1*x310))+(((-1.0)*cj1*r22))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x312=((1.0)+cj4);
IkReal x313=((1.0)*cj1);
IkReal x314=(cj0*py);
IkReal x315=((1.0)*px*sj0);
j3eval[0]=x312;
j3eval[1]=IKsign(x312);
j3eval[2]=((IKabs(((-1.0)+(((-1.0)*px*sj0*x313))+((cj1*x314))+(((-1.0)*x313))+((pz*sj1)))))+(IKabs(((-1.0)+(((-1.0)*sj1))+(((-1.0)*sj1*x315))+((sj1*x314))+(((-1.0)*pz*x313))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j3eval[0]=((1.0)+cj4);
j3eval[1]=sj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x316=((0.5)*sj1);
IkReal x317=((0.5)*cj1);
IkReal x318=(cj0*py);
IkReal x319=(px*sj0);
if( IKabs(((-0.5)+((x317*x318))+(((-1.0)*x317))+((pz*x316))+(((-1.0)*x317*x319)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.5)+(((-1.0)*x316))+(((-1.0)*pz*x317))+((x316*x318))+(((-1.0)*x316*x319)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.5)+((x317*x318))+(((-1.0)*x317))+((pz*x316))+(((-1.0)*x317*x319))))+IKsqr(((-0.5)+(((-1.0)*x316))+(((-1.0)*pz*x317))+((x316*x318))+(((-1.0)*x316*x319))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.5)+((x317*x318))+(((-1.0)*x317))+((pz*x316))+(((-1.0)*x317*x319))), ((-0.5)+(((-1.0)*x316))+(((-1.0)*pz*x317))+((x316*x318))+(((-1.0)*x316*x319))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x320=IKcos(j3);
CheckValue<IkReal> x341=IKPowWithIntegerCheck(px,-1);
if(!x341.valid){
continue;
}
IkReal x321=x341.value;
IkReal x322=((2.0)*cj1);
IkReal x323=((1.0)*pp);
IkReal x324=(cj1*rxp2_2);
IkReal x325=(cj1*sj0);
IkReal x326=(cj0*cj1);
IkReal x327=((2.0)*py);
IkReal x328=(pz*sj1);
IkReal x329=(px*sj0);
IkReal x330=(sj0*sj1);
IkReal x331=((1.0)*py);
IkReal x332=(cj0*sj1);
IkReal x333=((2.0)*(IKsin(j3)));
IkReal x334=((2.0)*x320);
IkReal x335=((4.0)*x320);
IkReal x336=((2.0)*x330);
IkReal x337=(py*rxp2_1*x321);
IkReal x338=((3.0)+x335);
IkReal x339=((1.0)+x334);
IkReal x340=(x322+x323);
evalcond[0]=(sj1+((cj1*pz))+x339+((sj1*x329))+(((-1.0)*x331*x332)));
evalcond[1]=((1.0)+cj1+(((-1.0)*x328))+x333+(((-1.0)*x326*x331))+((px*x325)));
evalcond[2]=((-1.0)+((x330*x337))+x324+(((-1.0)*x333))+((rxp2_0*x330))+(((-1.0)*cj1)));
evalcond[3]=(((r12*x330))+((r02*x332))+x339+(((-1.0)*rxp2_2*sj1))+(((-1.0)*rxp2_1*x326))+((rxp2_0*x325)));
evalcond[4]=(((rxp2_2*x322))+((rxp2_1*x321*x327*x330))+x338+(((2.0)*rxp2_2))+((rxp2_0*x336))+(((-1.0)*x340)));
evalcond[5]=((((-2.0)*x329))+(((-1.0)*x322*x329))+x338+((cj0*py*x322))+(((2.0)*x328))+((cj0*x327))+(((-1.0)*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x342=((1.0)*sj0);
IkReal x343=((1.0)*cj1);
CheckValue<IkReal> x344=IKPowWithIntegerCheck(((1.0)+cj4),-1);
if(!x344.valid){
continue;
}
CheckValue<IkReal> x345=IKPowWithIntegerCheck(sj4,-1);
if(!x345.valid){
continue;
}
if( IKabs(((x344.value)*(((-1.0)+(((-1.0)*cj1*px*x342))+((cj0*cj1*py))+((pz*sj1))+(((-1.0)*x343)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x345.value)*(((((-1.0)*r22*x343))+(((-1.0)*r02*sj1*x342))+((cj0*r12*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x344.value)*(((-1.0)+(((-1.0)*cj1*px*x342))+((cj0*cj1*py))+((pz*sj1))+(((-1.0)*x343))))))+IKsqr(((x345.value)*(((((-1.0)*r22*x343))+(((-1.0)*r02*sj1*x342))+((cj0*r12*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((x344.value)*(((-1.0)+(((-1.0)*cj1*px*x342))+((cj0*cj1*py))+((pz*sj1))+(((-1.0)*x343))))), ((x345.value)*(((((-1.0)*r22*x343))+(((-1.0)*r02*sj1*x342))+((cj0*r12*sj1))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x346=IKcos(j3);
IkReal x347=IKsin(j3);
CheckValue<IkReal> x383=IKPowWithIntegerCheck(px,-1);
if(!x383.valid){
continue;
}
IkReal x348=x383.value;
IkReal x349=((1.0)*cj0);
IkReal x350=(pp*r12);
IkReal x351=((2.0)*sj1);
IkReal x352=(npz*pz);
IkReal x353=(cj1*rxp2_2);
IkReal x354=((1.0)*cj1);
IkReal x355=(cj1*rxp2_1);
IkReal x356=((2.0)*cj0);
IkReal x357=(rxp2_0*sj0);
IkReal x358=((2.0)*sj4);
IkReal x359=((1.0)*cj4);
IkReal x360=((2.0)*r22);
IkReal x361=((2.0)*cj4);
IkReal x362=((1.0)*r22);
IkReal x363=(cj1*r22);
IkReal x364=(cj1*r12);
IkReal x365=(rxp2_1*sj0);
IkReal x366=((2.0)*cj1);
IkReal x367=(r02*sj0);
IkReal x368=(cj1*py);
IkReal x369=(px*sj0);
IkReal x370=((1.0)*sj1);
IkReal x371=(pp*sj1);
IkReal x372=(r12*sj1);
IkReal x373=(sj4*x346);
IkReal x374=(cj4*x346);
IkReal x375=((2.0)*x346);
IkReal x376=(sj4*x347);
IkReal x377=(rxp2_1*sj4*x348);
IkReal x378=(x346*x361);
IkReal x379=(py*x348*x365);
IkReal x380=(x366*x369);
IkReal x381=(x346+x374);
IkReal x382=(x378+x375);
evalcond[0]=(((sj1*x367))+x373+x363+(((-1.0)*x349*x372)));
evalcond[1]=((((-1.0)*sj1*x362))+x376+((cj1*x367))+(((-1.0)*x349*x364)));
evalcond[2]=((1.0)+sj1+((sj1*x369))+((cj1*pz))+x381+(((-1.0)*py*sj1*x349)));
evalcond[3]=((1.0)+cj1+x347+((cj4*x347))+((cj1*x369))+(((-1.0)*pz*x370))+(((-1.0)*x349*x368)));
evalcond[4]=((((-1.0)*x367))+sj4+(((-1.0)*x354*x367))+((r22*sj1))+(((-1.0)*npz))+x373+((cj0*x364))+((cj0*r12)));
evalcond[5]=((((-1.0)*x376))+(((-1.0)*x365))+(((-1.0)*r22*x354))+(((-1.0)*x362))+(((-1.0)*x367*x370))+((cj0*x372))+(((-1.0)*rxp2_0*x349)));
evalcond[6]=(((cj1*x357))+cj4+((sj0*x372))+(((-1.0)*x349*x355))+x381+(((-1.0)*rxp2_2*x370))+((cj0*r02*sj1)));
evalcond[7]=(((sj1*x377))+((sj1*x379))+(((-1.0)*x359))+x353+(((-1.0)*x347*x359))+((sj1*x357))+(((-1.0)*cj4*x354))+(((-1.0)*x347)));
evalcond[8]=((1.0)+(((-1.0)*x366))+((py*x356))+((pz*x351))+((x356*x368))+x382+x361+(((-1.0)*pp))+(((-1.0)*x380))+(((-2.0)*x369)));
evalcond[9]=((2.0)+((x351*x379))+((x351*x377))+cj4+(((-1.0)*npz*x358))+(((-1.0)*cj1*x361))+((x351*x357))+x382+(((2.0)*rxp2_2))+(((2.0)*x353))+(((-1.0)*pp*x359)));
evalcond[10]=(((x367*x371))+(((-1.0)*x373))+(((-1.0)*npz*x351*x369))+(((2.0)*sj0*x355))+((cj1*rxp2_0*x356))+((cj0*npz*py*x351))+(((-1.0)*sj1*x349*x350))+(((2.0)*x365))+(((-1.0)*x358))+(((-1.0)*x352*x366))+(((-1.0)*npz*x351))+x360+((cj1*x360))+((pp*x363))+((rxp2_0*x356)));
evalcond[11]=((((-1.0)*x362*x371))+((cj1*pp*x367))+((r12*x356))+(((-1.0)*npz*x380))+((npz*x356*x368))+(((-1.0)*cj0*rxp2_0*x351))+(((-1.0)*cj1*x349*x350))+((x356*x364))+((x351*x352))+x376+(((-1.0)*x366*x367))+(((-2.0)*npz))+(((-2.0)*x367))+(((-1.0)*npz*x366))+(((-1.0)*x351*x365)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x384=((1.0)*cj1);
IkReal x385=(cj0*py);
IkReal x386=((1.0)*px*sj0);
CheckValue<IkReal> x387 = IKatan2WithCheck(IkReal(((-1.0)+(((-1.0)*px*sj0*x384))+((cj1*x385))+(((-1.0)*x384))+((pz*sj1)))),IkReal(((-1.0)+(((-1.0)*sj1))+((sj1*x385))+(((-1.0)*sj1*x386))+(((-1.0)*pz*x384)))),IKFAST_ATAN2_MAGTHRESH);
if(!x387.valid){
continue;
}
CheckValue<IkReal> x388=IKPowWithIntegerCheck(IKsign(((1.0)+cj4)),-1);
if(!x388.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x387.value)+(((1.5707963267949)*(x388.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x389=IKcos(j3);
IkReal x390=IKsin(j3);
CheckValue<IkReal> x426=IKPowWithIntegerCheck(px,-1);
if(!x426.valid){
continue;
}
IkReal x391=x426.value;
IkReal x392=((1.0)*cj0);
IkReal x393=(pp*r12);
IkReal x394=((2.0)*sj1);
IkReal x395=(npz*pz);
IkReal x396=(cj1*rxp2_2);
IkReal x397=((1.0)*cj1);
IkReal x398=(cj1*rxp2_1);
IkReal x399=((2.0)*cj0);
IkReal x400=(rxp2_0*sj0);
IkReal x401=((2.0)*sj4);
IkReal x402=((1.0)*cj4);
IkReal x403=((2.0)*r22);
IkReal x404=((2.0)*cj4);
IkReal x405=((1.0)*r22);
IkReal x406=(cj1*r22);
IkReal x407=(cj1*r12);
IkReal x408=(rxp2_1*sj0);
IkReal x409=((2.0)*cj1);
IkReal x410=(r02*sj0);
IkReal x411=(cj1*py);
IkReal x412=(px*sj0);
IkReal x413=((1.0)*sj1);
IkReal x414=(pp*sj1);
IkReal x415=(r12*sj1);
IkReal x416=(sj4*x389);
IkReal x417=(cj4*x389);
IkReal x418=((2.0)*x389);
IkReal x419=(sj4*x390);
IkReal x420=(rxp2_1*sj4*x391);
IkReal x421=(x389*x404);
IkReal x422=(py*x391*x408);
IkReal x423=(x409*x412);
IkReal x424=(x389+x417);
IkReal x425=(x418+x421);
evalcond[0]=((((-1.0)*x392*x415))+((sj1*x410))+x406+x416);
evalcond[1]=((((-1.0)*x392*x407))+x419+((cj1*x410))+(((-1.0)*sj1*x405)));
evalcond[2]=((1.0)+sj1+((sj1*x412))+(((-1.0)*py*sj1*x392))+((cj1*pz))+x424);
evalcond[3]=((1.0)+(((-1.0)*x392*x411))+cj1+((cj4*x390))+x390+(((-1.0)*pz*x413))+((cj1*x412)));
evalcond[4]=(sj4+((r22*sj1))+((cj0*x407))+(((-1.0)*npz))+x416+(((-1.0)*x397*x410))+((cj0*r12))+(((-1.0)*x410)));
evalcond[5]=(((cj0*x415))+(((-1.0)*rxp2_0*x392))+(((-1.0)*x410*x413))+(((-1.0)*r22*x397))+(((-1.0)*x408))+(((-1.0)*x405))+(((-1.0)*x419)));
evalcond[6]=(cj4+((sj0*x415))+(((-1.0)*rxp2_2*x413))+x424+((cj1*x400))+((cj0*r02*sj1))+(((-1.0)*x392*x398)));
evalcond[7]=((((-1.0)*cj4*x397))+(((-1.0)*x390))+((sj1*x400))+x396+((sj1*x420))+((sj1*x422))+(((-1.0)*x402))+(((-1.0)*x390*x402)));
evalcond[8]=((1.0)+(((-1.0)*x423))+((pz*x394))+((py*x399))+(((-1.0)*pp))+x404+x425+((x399*x411))+(((-2.0)*x412))+(((-1.0)*x409)));
evalcond[9]=((2.0)+(((-1.0)*cj1*x404))+cj4+(((2.0)*x396))+(((-1.0)*npz*x401))+((x394*x422))+((x394*x420))+x425+(((2.0)*rxp2_2))+((x394*x400))+(((-1.0)*pp*x402)));
evalcond[10]=(((rxp2_0*x399))+((cj0*npz*py*x394))+((x410*x414))+(((2.0)*x408))+(((2.0)*sj0*x398))+(((-1.0)*x395*x409))+((pp*x406))+x403+((cj1*rxp2_0*x399))+(((-1.0)*npz*x394))+((cj1*x403))+(((-1.0)*npz*x394*x412))+(((-1.0)*sj1*x392*x393))+(((-1.0)*x401))+(((-1.0)*x416)));
evalcond[11]=(((cj1*pp*x410))+((npz*x399*x411))+(((-1.0)*cj1*x392*x393))+(((-1.0)*npz*x409))+((x394*x395))+(((-1.0)*npz*x423))+(((-1.0)*x394*x408))+(((-1.0)*cj0*rxp2_0*x394))+x419+(((-1.0)*x405*x414))+((x399*x407))+(((-2.0)*npz))+((r12*x399))+(((-2.0)*x410))+(((-1.0)*x409*x410)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x427=(cj0*r12);
IkReal x428=((1.0)*r02*sj0);
CheckValue<IkReal> x429 = IKatan2WithCheck(IkReal(((((-1.0)*cj1*x428))+((r22*sj1))+((cj1*x427)))),IkReal(((((-1.0)*sj1*x428))+(((-1.0)*cj1*r22))+((sj1*x427)))),IKFAST_ATAN2_MAGTHRESH);
if(!x429.valid){
continue;
}
CheckValue<IkReal> x430=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x430.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x429.value)+(((1.5707963267949)*(x430.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x431=IKcos(j3);
IkReal x432=IKsin(j3);
CheckValue<IkReal> x468=IKPowWithIntegerCheck(px,-1);
if(!x468.valid){
continue;
}
IkReal x433=x468.value;
IkReal x434=((1.0)*cj0);
IkReal x435=(pp*r12);
IkReal x436=((2.0)*sj1);
IkReal x437=(npz*pz);
IkReal x438=(cj1*rxp2_2);
IkReal x439=((1.0)*cj1);
IkReal x440=(cj1*rxp2_1);
IkReal x441=((2.0)*cj0);
IkReal x442=(rxp2_0*sj0);
IkReal x443=((2.0)*sj4);
IkReal x444=((1.0)*cj4);
IkReal x445=((2.0)*r22);
IkReal x446=((2.0)*cj4);
IkReal x447=((1.0)*r22);
IkReal x448=(cj1*r22);
IkReal x449=(cj1*r12);
IkReal x450=(rxp2_1*sj0);
IkReal x451=((2.0)*cj1);
IkReal x452=(r02*sj0);
IkReal x453=(cj1*py);
IkReal x454=(px*sj0);
IkReal x455=((1.0)*sj1);
IkReal x456=(pp*sj1);
IkReal x457=(r12*sj1);
IkReal x458=(sj4*x431);
IkReal x459=(cj4*x431);
IkReal x460=((2.0)*x431);
IkReal x461=(sj4*x432);
IkReal x462=(rxp2_1*sj4*x433);
IkReal x463=(x431*x446);
IkReal x464=(py*x433*x450);
IkReal x465=(x451*x454);
IkReal x466=(x431+x459);
IkReal x467=(x463+x460);
evalcond[0]=(x448+x458+((sj1*x452))+(((-1.0)*x434*x457)));
evalcond[1]=((((-1.0)*x434*x449))+((cj1*x452))+x461+(((-1.0)*sj1*x447)));
evalcond[2]=((1.0)+(((-1.0)*py*sj1*x434))+sj1+((cj1*pz))+x466+((sj1*x454)));
evalcond[3]=((1.0)+cj1+((cj1*x454))+((cj4*x432))+(((-1.0)*pz*x455))+x432+(((-1.0)*x434*x453)));
evalcond[4]=(sj4+(((-1.0)*x439*x452))+((r22*sj1))+(((-1.0)*x452))+(((-1.0)*npz))+((cj0*x449))+x458+((cj0*r12)));
evalcond[5]=((((-1.0)*rxp2_0*x434))+(((-1.0)*x447))+(((-1.0)*x450))+(((-1.0)*x461))+(((-1.0)*x452*x455))+((cj0*x457))+(((-1.0)*r22*x439)));
evalcond[6]=(cj4+((cj1*x442))+(((-1.0)*x434*x440))+x466+((sj0*x457))+(((-1.0)*rxp2_2*x455))+((cj0*r02*sj1)));
evalcond[7]=((((-1.0)*x444))+((sj1*x442))+(((-1.0)*x432))+(((-1.0)*x432*x444))+(((-1.0)*cj4*x439))+x438+((sj1*x464))+((sj1*x462)));
evalcond[8]=((1.0)+((x441*x453))+((pz*x436))+((py*x441))+(((-2.0)*x454))+(((-1.0)*x465))+(((-1.0)*x451))+(((-1.0)*pp))+x446+x467);
evalcond[9]=((2.0)+cj4+(((-1.0)*npz*x443))+(((-1.0)*cj1*x446))+x467+(((2.0)*rxp2_2))+(((2.0)*x438))+((x436*x462))+((x436*x464))+(((-1.0)*pp*x444))+((x436*x442)));
evalcond[10]=(((cj1*rxp2_0*x441))+(((-1.0)*x443))+((x452*x456))+((cj1*x445))+(((-1.0)*x437*x451))+((rxp2_0*x441))+(((-1.0)*npz*x436))+(((-1.0)*x458))+(((-1.0)*npz*x436*x454))+((pp*x448))+x445+(((2.0)*x450))+((cj0*npz*py*x436))+(((-1.0)*sj1*x434*x435))+(((2.0)*sj0*x440)));
evalcond[11]=(((x436*x437))+(((-1.0)*npz*x451))+(((-1.0)*npz*x465))+((cj1*pp*x452))+(((-2.0)*x452))+(((-1.0)*x447*x456))+(((-1.0)*x436*x450))+((x441*x449))+((npz*x441*x453))+x461+(((-1.0)*cj1*x434*x435))+(((-1.0)*x451*x452))+(((-2.0)*npz))+(((-1.0)*cj0*rxp2_0*x436))+((r12*x441)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x469=((0.5)*cj2);
IkReal x470=(pz*sj1);
IkReal x471=(px*sj0);
IkReal x472=((0.5)*sj2);
IkReal x473=(cj0*cj1*py);
IkReal x474=(cj1*x472);
IkReal x475=(cj0*py*sj1);
if( IKabs((((x471*x474))+((cj1*pz*x469))+(((-1.0)*x469*x475))+((sj1*x469*x471))+(((-1.0)*x472*x473))+x474+x472+((sj1*x469))+(((-1.0)*x470*x472)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.5)+((x469*x473))+((x469*x470))+((sj1*x471*x472))+(((-1.0)*cj1*x469*x471))+(((-1.0)*x469))+(((-1.0)*x472*x475))+(((-1.0)*cj1*x469))+((pz*x474))+((sj1*x472)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x471*x474))+((cj1*pz*x469))+(((-1.0)*x469*x475))+((sj1*x469*x471))+(((-1.0)*x472*x473))+x474+x472+((sj1*x469))+(((-1.0)*x470*x472))))+IKsqr(((-0.5)+((x469*x473))+((x469*x470))+((sj1*x471*x472))+(((-1.0)*cj1*x469*x471))+(((-1.0)*x469))+(((-1.0)*x472*x475))+(((-1.0)*cj1*x469))+((pz*x474))+((sj1*x472))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((((x471*x474))+((cj1*pz*x469))+(((-1.0)*x469*x475))+((sj1*x469*x471))+(((-1.0)*x472*x473))+x474+x472+((sj1*x469))+(((-1.0)*x470*x472))), ((-0.5)+((x469*x473))+((x469*x470))+((sj1*x471*x472))+(((-1.0)*cj1*x469*x471))+(((-1.0)*x469))+(((-1.0)*x472*x475))+(((-1.0)*cj1*x469))+((pz*x474))+((sj1*x472))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x476=IKcos(j3);
IkReal x477=IKsin(j3);
IkReal x478=((1.0)*sj2);
IkReal x479=(cj1*rxp2_2);
IkReal x480=(cj1*sj0);
IkReal x481=(cj0*cj1);
IkReal x482=((1.0)*rxp2_1);
IkReal x483=((2.0)*sj2);
IkReal x484=((2.0)*py);
IkReal x485=((2.0)*r12);
IkReal x486=((2.0)*sj0);
IkReal x487=(rxp2_0*sj1);
IkReal x488=((2.0)*r02);
IkReal x489=((1.0)*r02);
IkReal x490=(pz*sj1);
IkReal x491=((2.0)*cj0);
IkReal x492=(cj0*sj1);
IkReal x493=(sj0*sj1);
IkReal x494=((1.0)*py);
IkReal x495=((2.0)*cj2);
IkReal x496=((4.0)*x476);
IkReal x497=((1.0)*r12*sj0);
IkReal x498=(x476*x483);
IkReal x499=(x477*x495);
IkReal x500=(x477*x483);
IkReal x501=(x476*x495);
IkReal x502=(x498+x499+x478);
evalcond[0]=((1.0)+cj2+cj1+(((-1.0)*x500))+((px*x480))+(((-1.0)*x490))+x501+(((-1.0)*x481*x494)));
evalcond[1]=(sj1+(((-1.0)*x502))+((cj1*pz))+((px*x493))+(((-1.0)*x492*x494)));
evalcond[2]=((3.0)+(((2.0)*x490))+((cj0*x484))+((x481*x484))+(((-2.0)*px*x480))+(((-1.0)*pp))+x496+(((-1.0)*px*x486))+(((-2.0)*cj1)));
evalcond[3]=(((rxp2_0*x480))+((r02*x492))+(((-1.0)*x502))+(((-1.0)*x481*x482))+((r12*x493))+(((-1.0)*rxp2_2*sj1)));
evalcond[4]=((((-1.0)*x482*x492))+(((-1.0)*x497))+(((-1.0)*x501))+((sj0*x487))+(((-1.0)*x481*x489))+(((-1.0)*cj0*x489))+x479+x500+(((-1.0)*cj2))+(((-1.0)*r12*x480)));
evalcond[5]=((5.0)+(((-1.0)*cj0*pp*x489))+((npz*px*x491))+(((-1.0)*x481*x488))+(((-1.0)*cj0*x488))+x496+(((2.0)*rxp2_2))+(((-1.0)*x480*x485))+((npz*sj0*x484))+(((-1.0)*pp*x497))+((x486*x487))+(((-1.0)*rxp2_1*sj1*x491))+(((-1.0)*sj0*x485))+(((2.0)*x479)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x503=(cj0*r12);
IkReal x504=(r02*sj0);
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
j3eval[2]=((IKabs(((((-1.0)*sj1*x503))+((sj1*x504))+((cj1*r22)))))+(IKabs((((cj1*x503))+((r22*sj1))+(((-1.0)*cj1*x504))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x505=(r02*sj0);
IkReal x506=((1.0)*cj0*r12);
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
j3eval[2]=((IKabs(((((-1.0)*sj1*x506))+((sj1*x505))+((cj1*r22)))))+(IKabs(((((-1.0)*sj4))+((cj1*x505))+(((-1.0)*x506))+npz+x505+(((-1.0)*r22*sj1))+(((-1.0)*cj1*x506))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=0;
cj2=1.0;
j2=0;
j3eval[0]=sj4;
j3eval[1]=((1.0)+cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x507=((0.5)*sj1);
IkReal x508=((0.5)*cj1);
IkReal x509=(cj0*py);
IkReal x510=(px*sj0);
if( IKabs((((x507*x510))+(((-1.0)*x507*x509))+x507+((pz*x508)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)+(((-1.0)*x508))+((x508*x509))+(((-1.0)*x508*x510))+((pz*x507)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x507*x510))+(((-1.0)*x507*x509))+x507+((pz*x508))))+IKsqr(((-1.0)+(((-1.0)*x508))+((x508*x509))+(((-1.0)*x508*x510))+((pz*x507))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((((x507*x510))+(((-1.0)*x507*x509))+x507+((pz*x508))), ((-1.0)+(((-1.0)*x508))+((x508*x509))+(((-1.0)*x508*x510))+((pz*x507))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x511=IKcos(j3);
CheckValue<IkReal> x531=IKPowWithIntegerCheck(px,-1);
if(!x531.valid){
continue;
}
IkReal x512=x531.value;
IkReal x513=((2.0)*cj1);
IkReal x514=((1.0)*pp);
IkReal x515=(cj1*rxp2_2);
IkReal x516=(cj1*sj0);
IkReal x517=(cj0*cj1);
IkReal x518=((2.0)*py);
IkReal x519=(pz*sj1);
IkReal x520=(px*sj0);
IkReal x521=(sj0*sj1);
IkReal x522=((1.0)*py);
IkReal x523=(cj0*sj1);
IkReal x524=((2.0)*x511);
IkReal x525=((2.0)*(IKsin(j3)));
IkReal x526=((4.0)*x511);
IkReal x527=((2.0)*x521);
IkReal x528=(py*rxp2_1*x512);
IkReal x529=((3.0)+x526);
IkReal x530=(x514+x513);
evalcond[0]=(sj1+((sj1*x520))+(((-1.0)*x525))+((cj1*pz))+(((-1.0)*x522*x523)));
evalcond[1]=((2.0)+((px*x516))+cj1+(((-1.0)*x519))+(((-1.0)*x517*x522))+x524);
evalcond[2]=((-2.0)+((rxp2_0*x521))+(((-1.0)*x524))+((x521*x528))+x515+(((-1.0)*cj1)));
evalcond[3]=(((r02*x523))+((r12*x521))+((rxp2_0*x516))+(((-1.0)*x525))+(((-1.0)*rxp2_1*x517))+(((-1.0)*rxp2_2*sj1)));
evalcond[4]=(((rxp2_1*x512*x518*x521))+((rxp2_2*x513))+((rxp2_0*x527))+(((-1.0)*x530))+(((2.0)*rxp2_2))+x529);
evalcond[5]=((((-2.0)*x520))+((cj0*x518))+(((-1.0)*x530))+x529+(((2.0)*x519))+(((-1.0)*x513*x520))+((cj0*py*x513)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x532=((1.0)*cj1);
CheckValue<IkReal> x533=IKPowWithIntegerCheck(sj4,-1);
if(!x533.valid){
continue;
}
CheckValue<IkReal> x534=IKPowWithIntegerCheck(((1.0)+cj4),-1);
if(!x534.valid){
continue;
}
if( IKabs(((x533.value)*((((r02*sj0*sj1))+((cj1*r22))+(((-1.0)*cj0*r12*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x534.value)*(((-2.0)+(((-1.0)*px*sj0*x532))+(((-1.0)*x532))+((cj0*cj1*py))+((pz*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x533.value)*((((r02*sj0*sj1))+((cj1*r22))+(((-1.0)*cj0*r12*sj1))))))+IKsqr(((x534.value)*(((-2.0)+(((-1.0)*px*sj0*x532))+(((-1.0)*x532))+((cj0*cj1*py))+((pz*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((x533.value)*((((r02*sj0*sj1))+((cj1*r22))+(((-1.0)*cj0*r12*sj1))))), ((x534.value)*(((-2.0)+(((-1.0)*px*sj0*x532))+(((-1.0)*x532))+((cj0*cj1*py))+((pz*sj1))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x535=IKcos(j3);
IkReal x536=IKsin(j3);
CheckValue<IkReal> x573=IKPowWithIntegerCheck(px,-1);
if(!x573.valid){
continue;
}
IkReal x537=x573.value;
IkReal x538=((2.0)*cj4);
IkReal x539=((1.0)*cj0);
IkReal x540=(pp*r12);
IkReal x541=((2.0)*sj1);
IkReal x542=(npz*pz);
IkReal x543=(cj1*rxp2_2);
IkReal x544=((1.0)*cj1);
IkReal x545=(cj1*rxp2_1);
IkReal x546=((2.0)*cj0);
IkReal x547=(rxp2_0*sj0);
IkReal x548=((2.0)*sj4);
IkReal x549=((2.0)*r22);
IkReal x550=((1.0)*cj4);
IkReal x551=((1.0)*r22);
IkReal x552=(cj1*r22);
IkReal x553=(cj1*r12);
IkReal x554=(rxp2_1*sj0);
IkReal x555=((2.0)*cj1);
IkReal x556=(r02*sj0);
IkReal x557=(cj1*py);
IkReal x558=(px*sj0);
IkReal x559=((1.0)*sj1);
IkReal x560=(pp*sj1);
IkReal x561=(r12*sj1);
IkReal x562=(sj4*x535);
IkReal x563=((1.0)*x536);
IkReal x564=((2.0)*x535);
IkReal x565=(rxp2_1*sj4*x537);
IkReal x566=(sj4*x563);
IkReal x567=(x536*x550);
IkReal x568=(x535*x538);
IkReal x569=(py*x537*x554);
IkReal x570=(x555*x558);
IkReal x571=(x567+x563);
IkReal x572=(x568+x564);
evalcond[0]=(((sj1*x556))+(((-1.0)*x539*x561))+x552+(((-1.0)*x566)));
evalcond[1]=((((-1.0)*sj1*x551))+(((-1.0)*x539*x553))+((cj1*x556))+x562);
evalcond[2]=((2.0)+((cj4*x535))+cj1+(((-1.0)*x539*x557))+((cj1*x558))+x535+(((-1.0)*pz*x559)));
evalcond[3]=(((sj1*x558))+sj1+((cj1*pz))+(((-1.0)*py*sj1*x539))+(((-1.0)*x571)));
evalcond[4]=(((cj0*x553))+(((-1.0)*x556))+sj4+((r22*sj1))+(((-1.0)*x544*x556))+(((-1.0)*npz))+x562+((cj0*r12)));
evalcond[5]=((((-1.0)*x556*x559))+(((-1.0)*r22*x544))+(((-1.0)*x554))+((cj0*x561))+(((-1.0)*x551))+(((-1.0)*rxp2_0*x539))+(((-1.0)*x566)));
evalcond[6]=((((-1.0)*x539*x545))+((cj1*x547))+((sj0*x561))+(((-1.0)*x571))+((cj0*r02*sj1))+(((-1.0)*rxp2_2*x559)));
evalcond[7]=(((sj1*x547))+(((-1.0)*x535))+(((-1.0)*x538))+(((-1.0)*x535*x550))+((sj1*x565))+((sj1*x569))+x543+(((-1.0)*cj4*x544)));
evalcond[8]=((1.0)+((py*x546))+(((-1.0)*pp))+(((-1.0)*x555))+(((-1.0)*x570))+x538+x572+((x546*x557))+(((-2.0)*x558))+((pz*x541)));
evalcond[9]=((2.0)+(((-1.0)*npz*x548))+cj4+((x541*x547))+(((-1.0)*cj1*x538))+(((-1.0)*pp*x550))+((x541*x569))+((x541*x565))+(((2.0)*rxp2_2))+(((2.0)*x543))+x572);
evalcond[10]=(((pp*x552))+(((-1.0)*npz*x541))+((rxp2_0*x546))+((x556*x560))+(((-1.0)*sj1*x539*x540))+((cj1*x549))+(((2.0)*x554))+((cj1*rxp2_0*x546))+((cj0*npz*py*x541))+x549+(((-1.0)*npz*x541*x558))+(((2.0)*sj0*x545))+(((-1.0)*x542*x555))+(((-1.0)*x566)));
evalcond[11]=((((-1.0)*x555*x556))+((x541*x542))+((cj1*pp*x556))+(((-1.0)*cj0*rxp2_0*x541))+(((-1.0)*npz*x555))+((r12*x546))+(((-1.0)*x548))+(((-1.0)*x562))+((npz*x546*x557))+(((-2.0)*npz))+(((-1.0)*x551*x560))+((x546*x553))+(((-1.0)*cj1*x539*x540))+(((-1.0)*x541*x554))+(((-2.0)*x556))+(((-1.0)*npz*x570)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x574=(r02*sj0);
IkReal x575=((1.0)*cj0*r12);
CheckValue<IkReal> x576 = IKatan2WithCheck(IkReal((((sj1*x574))+(((-1.0)*sj1*x575))+((cj1*r22)))),IkReal(((((-1.0)*sj4))+npz+(((-1.0)*cj1*x575))+(((-1.0)*x575))+x574+(((-1.0)*r22*sj1))+((cj1*x574)))),IKFAST_ATAN2_MAGTHRESH);
if(!x576.valid){
continue;
}
CheckValue<IkReal> x577=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x577.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x576.value)+(((1.5707963267949)*(x577.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x578=IKcos(j3);
IkReal x579=IKsin(j3);
CheckValue<IkReal> x616=IKPowWithIntegerCheck(px,-1);
if(!x616.valid){
continue;
}
IkReal x580=x616.value;
IkReal x581=((2.0)*cj4);
IkReal x582=((1.0)*cj0);
IkReal x583=(pp*r12);
IkReal x584=((2.0)*sj1);
IkReal x585=(npz*pz);
IkReal x586=(cj1*rxp2_2);
IkReal x587=((1.0)*cj1);
IkReal x588=(cj1*rxp2_1);
IkReal x589=((2.0)*cj0);
IkReal x590=(rxp2_0*sj0);
IkReal x591=((2.0)*sj4);
IkReal x592=((2.0)*r22);
IkReal x593=((1.0)*cj4);
IkReal x594=((1.0)*r22);
IkReal x595=(cj1*r22);
IkReal x596=(cj1*r12);
IkReal x597=(rxp2_1*sj0);
IkReal x598=((2.0)*cj1);
IkReal x599=(r02*sj0);
IkReal x600=(cj1*py);
IkReal x601=(px*sj0);
IkReal x602=((1.0)*sj1);
IkReal x603=(pp*sj1);
IkReal x604=(r12*sj1);
IkReal x605=(sj4*x578);
IkReal x606=((1.0)*x579);
IkReal x607=((2.0)*x578);
IkReal x608=(rxp2_1*sj4*x580);
IkReal x609=(sj4*x606);
IkReal x610=(x579*x593);
IkReal x611=(x578*x581);
IkReal x612=(py*x580*x597);
IkReal x613=(x598*x601);
IkReal x614=(x606+x610);
IkReal x615=(x607+x611);
evalcond[0]=(x595+(((-1.0)*x582*x604))+(((-1.0)*x609))+((sj1*x599)));
evalcond[1]=(((cj1*x599))+(((-1.0)*sj1*x594))+x605+(((-1.0)*x582*x596)));
evalcond[2]=((2.0)+cj1+((cj1*x601))+x578+(((-1.0)*x582*x600))+(((-1.0)*pz*x602))+((cj4*x578)));
evalcond[3]=(sj1+((sj1*x601))+((cj1*pz))+(((-1.0)*x614))+(((-1.0)*py*sj1*x582)));
evalcond[4]=(sj4+(((-1.0)*x587*x599))+((r22*sj1))+(((-1.0)*x599))+(((-1.0)*npz))+x605+((cj0*r12))+((cj0*x596)));
evalcond[5]=((((-1.0)*rxp2_0*x582))+(((-1.0)*r22*x587))+(((-1.0)*x597))+(((-1.0)*x599*x602))+(((-1.0)*x594))+(((-1.0)*x609))+((cj0*x604)));
evalcond[6]=(((sj0*x604))+(((-1.0)*x582*x588))+((cj1*x590))+(((-1.0)*rxp2_2*x602))+(((-1.0)*x614))+((cj0*r02*sj1)));
evalcond[7]=(((sj1*x608))+((sj1*x612))+(((-1.0)*cj4*x587))+(((-1.0)*x578))+x586+((sj1*x590))+(((-1.0)*x581))+(((-1.0)*x578*x593)));
evalcond[8]=((1.0)+((x589*x600))+(((-1.0)*x598))+(((-1.0)*pp))+(((-2.0)*x601))+x581+(((-1.0)*x613))+x615+((py*x589))+((pz*x584)));
evalcond[9]=((2.0)+((x584*x608))+((x584*x612))+cj4+(((-1.0)*pp*x593))+(((2.0)*rxp2_2))+((x584*x590))+x615+(((-1.0)*cj1*x581))+(((2.0)*x586))+(((-1.0)*npz*x591)));
evalcond[10]=((((-1.0)*sj1*x582*x583))+((rxp2_0*x589))+((cj1*rxp2_0*x589))+((cj1*x592))+(((-1.0)*x585*x598))+(((2.0)*x597))+((pp*x595))+((cj0*npz*py*x584))+x592+(((-1.0)*npz*x584))+(((-1.0)*x609))+((x599*x603))+(((2.0)*sj0*x588))+(((-1.0)*npz*x584*x601)));
evalcond[11]=(((x584*x585))+(((-1.0)*x598*x599))+((cj1*pp*x599))+((r12*x589))+((npz*x589*x600))+(((-2.0)*x599))+(((-1.0)*x605))+(((-1.0)*cj1*x582*x583))+(((-1.0)*x591))+(((-1.0)*x584*x597))+(((-1.0)*npz*x613))+(((-2.0)*npz))+((x589*x596))+(((-1.0)*npz*x598))+(((-1.0)*x594*x603))+(((-1.0)*cj0*rxp2_0*x584)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x617=(cj0*r12);
IkReal x618=(r02*sj0);
CheckValue<IkReal> x619 = IKatan2WithCheck(IkReal((((sj1*x618))+((cj1*r22))+(((-1.0)*sj1*x617)))),IkReal((((r22*sj1))+(((-1.0)*cj1*x618))+((cj1*x617)))),IKFAST_ATAN2_MAGTHRESH);
if(!x619.valid){
continue;
}
CheckValue<IkReal> x620=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x620.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x619.value)+(((1.5707963267949)*(x620.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x621=IKcos(j3);
IkReal x622=IKsin(j3);
CheckValue<IkReal> x659=IKPowWithIntegerCheck(px,-1);
if(!x659.valid){
continue;
}
IkReal x623=x659.value;
IkReal x624=((2.0)*cj4);
IkReal x625=((1.0)*cj0);
IkReal x626=(pp*r12);
IkReal x627=((2.0)*sj1);
IkReal x628=(npz*pz);
IkReal x629=(cj1*rxp2_2);
IkReal x630=((1.0)*cj1);
IkReal x631=(cj1*rxp2_1);
IkReal x632=((2.0)*cj0);
IkReal x633=(rxp2_0*sj0);
IkReal x634=((2.0)*sj4);
IkReal x635=((2.0)*r22);
IkReal x636=((1.0)*cj4);
IkReal x637=((1.0)*r22);
IkReal x638=(cj1*r22);
IkReal x639=(cj1*r12);
IkReal x640=(rxp2_1*sj0);
IkReal x641=((2.0)*cj1);
IkReal x642=(r02*sj0);
IkReal x643=(cj1*py);
IkReal x644=(px*sj0);
IkReal x645=((1.0)*sj1);
IkReal x646=(pp*sj1);
IkReal x647=(r12*sj1);
IkReal x648=(sj4*x621);
IkReal x649=((1.0)*x622);
IkReal x650=((2.0)*x621);
IkReal x651=(rxp2_1*sj4*x623);
IkReal x652=(sj4*x649);
IkReal x653=(x622*x636);
IkReal x654=(x621*x624);
IkReal x655=(py*x623*x640);
IkReal x656=(x641*x644);
IkReal x657=(x649+x653);
IkReal x658=(x650+x654);
evalcond[0]=((((-1.0)*x625*x647))+((sj1*x642))+(((-1.0)*x652))+x638);
evalcond[1]=(((cj1*x642))+x648+(((-1.0)*x625*x639))+(((-1.0)*sj1*x637)));
evalcond[2]=((2.0)+cj1+(((-1.0)*x625*x643))+((cj4*x621))+((cj1*x644))+x621+(((-1.0)*pz*x645)));
evalcond[3]=(sj1+((sj1*x644))+((cj1*pz))+(((-1.0)*x657))+(((-1.0)*py*sj1*x625)));
evalcond[4]=(sj4+(((-1.0)*x642))+(((-1.0)*x630*x642))+((r22*sj1))+(((-1.0)*npz))+((cj0*x639))+x648+((cj0*r12)));
evalcond[5]=((((-1.0)*x642*x645))+(((-1.0)*x640))+(((-1.0)*rxp2_0*x625))+(((-1.0)*x637))+(((-1.0)*x652))+((cj0*x647))+(((-1.0)*r22*x630)));
evalcond[6]=(((sj0*x647))+(((-1.0)*x657))+(((-1.0)*rxp2_2*x645))+(((-1.0)*x625*x631))+((cj0*r02*sj1))+((cj1*x633)));
evalcond[7]=((((-1.0)*x621*x636))+((sj1*x655))+((sj1*x651))+(((-1.0)*x624))+(((-1.0)*cj4*x630))+((sj1*x633))+x629+(((-1.0)*x621)));
evalcond[8]=((1.0)+((py*x632))+((pz*x627))+(((-1.0)*x656))+(((-1.0)*pp))+(((-1.0)*x641))+((x632*x643))+x658+x624+(((-2.0)*x644)));
evalcond[9]=((2.0)+(((-1.0)*pp*x636))+(((-1.0)*cj1*x624))+(((2.0)*x629))+(((-1.0)*npz*x634))+cj4+(((2.0)*rxp2_2))+x658+((x627*x633))+((x627*x651))+((x627*x655)));
evalcond[10]=(((cj1*rxp2_0*x632))+(((-1.0)*npz*x627))+(((-1.0)*sj1*x625*x626))+(((2.0)*x640))+(((2.0)*sj0*x631))+((pp*x638))+(((-1.0)*x652))+x635+(((-1.0)*x628*x641))+((rxp2_0*x632))+((cj0*npz*py*x627))+((cj1*x635))+((x642*x646))+(((-1.0)*npz*x627*x644)));
evalcond[11]=((((-1.0)*npz*x641))+(((-1.0)*x648))+(((-1.0)*x627*x640))+(((-1.0)*x641*x642))+(((-1.0)*cj1*x625*x626))+(((-1.0)*x634))+((cj1*pp*x642))+((npz*x632*x643))+(((-1.0)*cj0*rxp2_0*x627))+(((-2.0)*npz))+(((-1.0)*x637*x646))+((r12*x632))+((x632*x639))+(((-1.0)*npz*x656))+(((-2.0)*x642))+((x627*x628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x660=((1.0)*sj1);
IkReal x661=(cj0*r12);
IkReal x662=((1.0)*cj1);
IkReal x663=(r02*sj0);
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
j3eval[2]=((IKabs(((((-1.0)*r22*x662))+((sj1*x661))+(((-1.0)*x660*x663)))))+(IKabs(((((-1.0)*r22*x660))+(((-1.0)*x661*x662))+((cj1*x663))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x664=((1.0)*sj1);
IkReal x665=(r02*sj0);
IkReal x666=((1.0)*cj0*r12);
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
j3eval[2]=((IKabs(((((-1.0)*cj1*r22))+((cj0*r12*sj1))+(((-1.0)*x664*x665)))))+(IKabs(((((-1.0)*sj4))+(((-1.0)*r22*x664))+npz+(((-1.0)*cj1*x666))+(((-1.0)*x666))+x665+((cj1*x665))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j3eval[0]=((1.0)+cj4);
j3eval[1]=sj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x667=((0.5)*sj1);
IkReal x668=((0.5)*cj1);
IkReal x669=(cj0*py);
IkReal x670=(px*sj0);
if( IKabs((((x667*x669))+(((-1.0)*x667*x670))+(((-1.0)*x667))+(((-1.0)*pz*x668)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x668*x669))+((x668*x670))+x668+(((-1.0)*pz*x667)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x667*x669))+(((-1.0)*x667*x670))+(((-1.0)*x667))+(((-1.0)*pz*x668))))+IKsqr(((((-1.0)*x668*x669))+((x668*x670))+x668+(((-1.0)*pz*x667))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((((x667*x669))+(((-1.0)*x667*x670))+(((-1.0)*x667))+(((-1.0)*pz*x668))), ((((-1.0)*x668*x669))+((x668*x670))+x668+(((-1.0)*pz*x667))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x671=IKcos(j3);
CheckValue<IkReal> x691=IKPowWithIntegerCheck(px,-1);
if(!x691.valid){
continue;
}
IkReal x672=x691.value;
IkReal x673=((2.0)*cj1);
IkReal x674=((1.0)*pp);
IkReal x675=(cj1*rxp2_2);
IkReal x676=(cj1*sj0);
IkReal x677=(cj0*cj1);
IkReal x678=((2.0)*py);
IkReal x679=(pz*sj1);
IkReal x680=(px*sj0);
IkReal x681=(sj0*sj1);
IkReal x682=((1.0)*py);
IkReal x683=(cj0*sj1);
IkReal x684=((2.0)*x671);
IkReal x685=((2.0)*(IKsin(j3)));
IkReal x686=((4.0)*x671);
IkReal x687=((2.0)*x681);
IkReal x688=(py*rxp2_1*x672);
IkReal x689=((3.0)+x686);
IkReal x690=(x673+x674);
evalcond[0]=(sj1+((cj1*pz))+x685+(((-1.0)*x682*x683))+((sj1*x680)));
evalcond[1]=(cj1+(((-1.0)*x684))+(((-1.0)*x679))+(((-1.0)*x677*x682))+((px*x676)));
evalcond[2]=(((x681*x688))+x675+x684+((rxp2_0*x681))+(((-1.0)*cj1)));
evalcond[3]=(((rxp2_0*x676))+(((-1.0)*rxp2_2*sj1))+x685+(((-1.0)*rxp2_1*x677))+((r02*x683))+((r12*x681)));
evalcond[4]=(((rxp2_1*x672*x678*x681))+((rxp2_2*x673))+(((2.0)*rxp2_2))+x689+(((-1.0)*x690))+((rxp2_0*x687)));
evalcond[5]=((((-2.0)*x680))+((cj0*x678))+(((-1.0)*x673*x680))+x689+(((-1.0)*x690))+((cj0*py*x673))+(((2.0)*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x692=((1.0)*sj1);
IkReal x693=((1.0)*cj1);
CheckValue<IkReal> x694=IKPowWithIntegerCheck(((1.0)+cj4),-1);
if(!x694.valid){
continue;
}
CheckValue<IkReal> x695=IKPowWithIntegerCheck(sj4,-1);
if(!x695.valid){
continue;
}
if( IKabs(((x694.value)*((((cj0*py*sj1))+(((-1.0)*px*sj0*x692))+(((-1.0)*pz*x693))+(((-1.0)*x692)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x695.value)*(((((-1.0)*cj0*r12*x693))+(((-1.0)*r22*x692))+((cj1*r02*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x694.value)*((((cj0*py*sj1))+(((-1.0)*px*sj0*x692))+(((-1.0)*pz*x693))+(((-1.0)*x692))))))+IKsqr(((x695.value)*(((((-1.0)*cj0*r12*x693))+(((-1.0)*r22*x692))+((cj1*r02*sj0))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((x694.value)*((((cj0*py*sj1))+(((-1.0)*px*sj0*x692))+(((-1.0)*pz*x693))+(((-1.0)*x692))))), ((x695.value)*(((((-1.0)*cj0*r12*x693))+(((-1.0)*r22*x692))+((cj1*r02*sj0))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x696=IKsin(j3);
IkReal x697=IKcos(j3);
CheckValue<IkReal> x733=IKPowWithIntegerCheck(px,-1);
if(!x733.valid){
continue;
}
IkReal x698=x733.value;
IkReal x699=((1.0)*cj0);
IkReal x700=(pp*r12);
IkReal x701=((2.0)*sj1);
IkReal x702=(npz*pz);
IkReal x703=(cj1*rxp2_2);
IkReal x704=((1.0)*cj1);
IkReal x705=(cj1*rxp2_1);
IkReal x706=((2.0)*cj0);
IkReal x707=(rxp2_0*sj0);
IkReal x708=((2.0)*sj4);
IkReal x709=((2.0)*r22);
IkReal x710=((2.0)*cj4);
IkReal x711=((1.0)*cj4);
IkReal x712=((1.0)*r22);
IkReal x713=(cj1*r22);
IkReal x714=(cj1*r12);
IkReal x715=(rxp2_1*sj0);
IkReal x716=((2.0)*cj1);
IkReal x717=(r02*sj0);
IkReal x718=(cj1*py);
IkReal x719=(px*sj0);
IkReal x720=((1.0)*sj1);
IkReal x721=(pp*sj1);
IkReal x722=(r12*sj1);
IkReal x723=(cj4*x696);
IkReal x724=((2.0)*x697);
IkReal x725=(sj4*x696);
IkReal x726=(sj4*x697);
IkReal x727=(rxp2_1*sj4*x698);
IkReal x728=(x697*x710);
IkReal x729=(py*x698*x715);
IkReal x730=(x716*x719);
IkReal x731=(x696+x723);
IkReal x732=(x724+x728);
evalcond[0]=(((sj1*x717))+x713+x725+(((-1.0)*x699*x722)));
evalcond[1]=((((-1.0)*x726))+(((-1.0)*x699*x714))+(((-1.0)*sj1*x712))+((cj1*x717)));
evalcond[2]=(sj1+(((-1.0)*py*sj1*x699))+((cj1*pz))+((sj1*x719))+x731);
evalcond[3]=(cj1+(((-1.0)*x699*x718))+(((-1.0)*x697*x711))+((cj1*x719))+(((-1.0)*pz*x720))+(((-1.0)*x697)));
evalcond[4]=(sj4+((r22*sj1))+(((-1.0)*x717))+(((-1.0)*npz))+((cj0*x714))+(((-1.0)*x704*x717))+x726+((cj0*r12)));
evalcond[5]=((((-1.0)*x699*x705))+(((-1.0)*rxp2_2*x720))+x731+((sj0*x722))+((cj1*x707))+((cj0*r02*sj1)));
evalcond[6]=((((-1.0)*x715))+(((-1.0)*x717*x720))+((cj0*x722))+(((-1.0)*x725))+(((-1.0)*x712))+(((-1.0)*rxp2_0*x699))+(((-1.0)*r22*x704)));
evalcond[7]=(((cj4*x697))+x697+((sj1*x707))+x703+(((-1.0)*cj4*x704))+((sj1*x729))+((sj1*x727)));
evalcond[8]=((1.0)+((x706*x718))+(((-2.0)*x719))+(((-1.0)*pp))+(((-1.0)*x730))+(((-1.0)*x716))+x710+x732+((py*x706))+((pz*x701)));
evalcond[9]=((2.0)+((x701*x729))+((x701*x727))+((x701*x707))+cj4+(((-1.0)*npz*x708))+(((-1.0)*cj1*x710))+(((2.0)*rxp2_2))+(((2.0)*x703))+x732+(((-1.0)*pp*x711)));
evalcond[10]=((((-1.0)*sj1*x699*x700))+(((-1.0)*x702*x716))+((x717*x721))+(((-1.0)*npz*x701))+((rxp2_0*x706))+(((-1.0)*npz*x701*x719))+(((2.0)*sj0*x705))+(((2.0)*x715))+((pp*x713))+x709+x725+((cj1*rxp2_0*x706))+((cj1*x709))+((cj0*npz*py*x701)));
evalcond[11]=(((x701*x702))+((cj1*pp*x717))+(((-1.0)*npz*x730))+((x706*x714))+(((-2.0)*x717))+((npz*x706*x718))+(((-1.0)*npz*x716))+(((-1.0)*x716*x717))+(((-1.0)*cj0*rxp2_0*x701))+(((-1.0)*cj1*x699*x700))+(((-2.0)*npz))+x708+x726+((r12*x706))+(((-1.0)*x701*x715))+(((-1.0)*x712*x721)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x734=((1.0)*sj1);
IkReal x735=(r02*sj0);
IkReal x736=((1.0)*cj0*r12);
CheckValue<IkReal> x737 = IKatan2WithCheck(IkReal(((((-1.0)*x734*x735))+(((-1.0)*cj1*r22))+((cj0*r12*sj1)))),IkReal(((((-1.0)*sj4))+npz+(((-1.0)*cj1*x736))+(((-1.0)*x736))+x735+(((-1.0)*r22*x734))+((cj1*x735)))),IKFAST_ATAN2_MAGTHRESH);
if(!x737.valid){
continue;
}
CheckValue<IkReal> x738=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x738.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x737.value)+(((1.5707963267949)*(x738.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x739=IKsin(j3);
IkReal x740=IKcos(j3);
CheckValue<IkReal> x776=IKPowWithIntegerCheck(px,-1);
if(!x776.valid){
continue;
}
IkReal x741=x776.value;
IkReal x742=((1.0)*cj0);
IkReal x743=(pp*r12);
IkReal x744=((2.0)*sj1);
IkReal x745=(npz*pz);
IkReal x746=(cj1*rxp2_2);
IkReal x747=((1.0)*cj1);
IkReal x748=(cj1*rxp2_1);
IkReal x749=((2.0)*cj0);
IkReal x750=(rxp2_0*sj0);
IkReal x751=((2.0)*sj4);
IkReal x752=((2.0)*r22);
IkReal x753=((2.0)*cj4);
IkReal x754=((1.0)*cj4);
IkReal x755=((1.0)*r22);
IkReal x756=(cj1*r22);
IkReal x757=(cj1*r12);
IkReal x758=(rxp2_1*sj0);
IkReal x759=((2.0)*cj1);
IkReal x760=(r02*sj0);
IkReal x761=(cj1*py);
IkReal x762=(px*sj0);
IkReal x763=((1.0)*sj1);
IkReal x764=(pp*sj1);
IkReal x765=(r12*sj1);
IkReal x766=(cj4*x739);
IkReal x767=((2.0)*x740);
IkReal x768=(sj4*x739);
IkReal x769=(sj4*x740);
IkReal x770=(rxp2_1*sj4*x741);
IkReal x771=(x740*x753);
IkReal x772=(py*x741*x758);
IkReal x773=(x759*x762);
IkReal x774=(x739+x766);
IkReal x775=(x771+x767);
evalcond[0]=(((sj1*x760))+(((-1.0)*x742*x765))+x756+x768);
evalcond[1]=((((-1.0)*x742*x757))+(((-1.0)*sj1*x755))+((cj1*x760))+(((-1.0)*x769)));
evalcond[2]=((((-1.0)*py*sj1*x742))+sj1+((sj1*x762))+((cj1*pz))+x774);
evalcond[3]=(((cj1*x762))+cj1+(((-1.0)*x742*x761))+(((-1.0)*x740))+(((-1.0)*x740*x754))+(((-1.0)*pz*x763)));
evalcond[4]=(sj4+((r22*sj1))+(((-1.0)*npz))+(((-1.0)*x747*x760))+((cj0*x757))+(((-1.0)*x760))+x769+((cj0*r12)));
evalcond[5]=(((cj1*x750))+((sj0*x765))+(((-1.0)*x742*x748))+(((-1.0)*rxp2_2*x763))+x774+((cj0*r02*sj1)));
evalcond[6]=((((-1.0)*rxp2_0*x742))+(((-1.0)*r22*x747))+(((-1.0)*x768))+((cj0*x765))+(((-1.0)*x758))+(((-1.0)*x760*x763))+(((-1.0)*x755)));
evalcond[7]=((((-1.0)*cj4*x747))+((sj1*x750))+((sj1*x770))+((sj1*x772))+x746+x740+((cj4*x740)));
evalcond[8]=((1.0)+((py*x749))+(((-2.0)*x762))+(((-1.0)*pp))+x753+x775+(((-1.0)*x773))+(((-1.0)*x759))+((x749*x761))+((pz*x744)));
evalcond[9]=((2.0)+(((2.0)*x746))+cj4+(((-1.0)*npz*x751))+(((-1.0)*pp*x754))+((x744*x772))+((x744*x770))+((x744*x750))+(((2.0)*rxp2_2))+(((-1.0)*cj1*x753))+x775);
evalcond[10]=((((2.0)*sj0*x748))+(((-1.0)*x745*x759))+((cj1*x752))+(((-1.0)*npz*x744*x762))+((pp*x756))+((x760*x764))+((cj0*npz*py*x744))+((cj1*rxp2_0*x749))+(((-1.0)*sj1*x742*x743))+x752+x768+((rxp2_0*x749))+(((2.0)*x758))+(((-1.0)*npz*x744)));
evalcond[11]=((((-1.0)*npz*x773))+(((-1.0)*cj0*rxp2_0*x744))+(((-1.0)*npz*x759))+(((-2.0)*x760))+((x744*x745))+(((-1.0)*cj1*x742*x743))+((cj1*pp*x760))+(((-1.0)*x755*x764))+((npz*x749*x761))+(((-1.0)*x744*x758))+((r12*x749))+(((-2.0)*npz))+x751+x769+((x749*x757))+(((-1.0)*x759*x760)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x777=((1.0)*sj1);
IkReal x778=(cj0*r12);
IkReal x779=((1.0)*cj1);
IkReal x780=(r02*sj0);
CheckValue<IkReal> x781=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x781.valid){
continue;
}
CheckValue<IkReal> x782 = IKatan2WithCheck(IkReal(((((-1.0)*x777*x780))+(((-1.0)*r22*x779))+((sj1*x778)))),IkReal(((((-1.0)*x778*x779))+((cj1*x780))+(((-1.0)*r22*x777)))),IKFAST_ATAN2_MAGTHRESH);
if(!x782.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x781.value)))+(x782.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x783=IKsin(j3);
IkReal x784=IKcos(j3);
CheckValue<IkReal> x820=IKPowWithIntegerCheck(px,-1);
if(!x820.valid){
continue;
}
IkReal x785=x820.value;
IkReal x786=((1.0)*cj0);
IkReal x787=(pp*r12);
IkReal x788=((2.0)*sj1);
IkReal x789=(npz*pz);
IkReal x790=(cj1*rxp2_2);
IkReal x791=((1.0)*cj1);
IkReal x792=(cj1*rxp2_1);
IkReal x793=((2.0)*cj0);
IkReal x794=(rxp2_0*sj0);
IkReal x795=((2.0)*sj4);
IkReal x796=((2.0)*r22);
IkReal x797=((2.0)*cj4);
IkReal x798=((1.0)*cj4);
IkReal x799=((1.0)*r22);
IkReal x800=(cj1*r22);
IkReal x801=(cj1*r12);
IkReal x802=(rxp2_1*sj0);
IkReal x803=((2.0)*cj1);
IkReal x804=(r02*sj0);
IkReal x805=(cj1*py);
IkReal x806=(px*sj0);
IkReal x807=((1.0)*sj1);
IkReal x808=(pp*sj1);
IkReal x809=(r12*sj1);
IkReal x810=(cj4*x783);
IkReal x811=((2.0)*x784);
IkReal x812=(sj4*x783);
IkReal x813=(sj4*x784);
IkReal x814=(rxp2_1*sj4*x785);
IkReal x815=(x784*x797);
IkReal x816=(py*x785*x802);
IkReal x817=(x803*x806);
IkReal x818=(x783+x810);
IkReal x819=(x815+x811);
evalcond[0]=((((-1.0)*x786*x809))+((sj1*x804))+x812+x800);
evalcond[1]=((((-1.0)*x786*x801))+((cj1*x804))+(((-1.0)*x813))+(((-1.0)*sj1*x799)));
evalcond[2]=(sj1+((cj1*pz))+((sj1*x806))+x818+(((-1.0)*py*sj1*x786)));
evalcond[3]=(cj1+(((-1.0)*x786*x805))+((cj1*x806))+(((-1.0)*x784*x798))+(((-1.0)*x784))+(((-1.0)*pz*x807)));
evalcond[4]=((((-1.0)*x804))+sj4+((r22*sj1))+(((-1.0)*x791*x804))+(((-1.0)*npz))+((cj0*x801))+x813+((cj0*r12)));
evalcond[5]=((((-1.0)*rxp2_2*x807))+((cj1*x794))+((sj0*x809))+(((-1.0)*x786*x792))+x818+((cj0*r02*sj1)));
evalcond[6]=((((-1.0)*x802))+(((-1.0)*x804*x807))+(((-1.0)*x799))+(((-1.0)*rxp2_0*x786))+(((-1.0)*x812))+((cj0*x809))+(((-1.0)*r22*x791)));
evalcond[7]=(((sj1*x816))+((sj1*x814))+((sj1*x794))+((cj4*x784))+x790+x784+(((-1.0)*cj4*x791)));
evalcond[8]=((1.0)+((x793*x805))+(((-1.0)*x817))+((pz*x788))+(((-1.0)*pp))+(((-2.0)*x806))+((py*x793))+x797+x819+(((-1.0)*x803)));
evalcond[9]=((2.0)+cj4+(((-1.0)*pp*x798))+((x788*x794))+(((-1.0)*npz*x795))+((x788*x814))+((x788*x816))+(((2.0)*rxp2_2))+(((-1.0)*cj1*x797))+x819+(((2.0)*x790)));
evalcond[10]=((((-1.0)*sj1*x786*x787))+((rxp2_0*x793))+((x804*x808))+(((-1.0)*npz*x788*x806))+((pp*x800))+((cj1*x796))+((cj0*npz*py*x788))+(((-1.0)*npz*x788))+(((-1.0)*x789*x803))+(((2.0)*x802))+(((2.0)*sj0*x792))+x796+x812+((cj1*rxp2_0*x793)));
evalcond[11]=((((-1.0)*cj0*rxp2_0*x788))+(((-1.0)*npz*x803))+((x793*x801))+(((-1.0)*x799*x808))+((x788*x789))+(((-1.0)*cj1*x786*x787))+(((-1.0)*npz*x817))+(((-2.0)*x804))+((npz*x793*x805))+((cj1*pp*x804))+(((-1.0)*x788*x802))+(((-1.0)*x803*x804))+(((-2.0)*npz))+x795+x813+((r12*x793)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x828=IKPowWithIntegerCheck(sj4,-1);
if(!x828.valid){
continue;
}
IkReal x821=x828.value;
IkReal x822=((1.0)*sj2);
IkReal x823=(r22*sj1);
IkReal x824=(r02*sj0);
IkReal x825=((1.0)*cj0*r12);
IkReal x826=(cj1*x824);
IkReal x827=(cj0*r12*sj2);
CheckValue<IkReal> x829=IKPowWithIntegerCheck(cj2,-1);
if(!x829.valid){
continue;
}
if( IKabs((x821*(x829.value)*((((sj2*sj4))+(((-1.0)*x822*x826))+(((-1.0)*x822*x824))+(((-1.0)*npz*x822))+((sj1*x824))+((sj2*x823))+((cj1*r22))+(((-1.0)*sj1*x825))+x827+((cj1*x827)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x821*(((((-1.0)*sj4))+(((-1.0)*x825))+npz+(((-1.0)*x823))+x826+x824+(((-1.0)*cj1*x825)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x821*(x829.value)*((((sj2*sj4))+(((-1.0)*x822*x826))+(((-1.0)*x822*x824))+(((-1.0)*npz*x822))+((sj1*x824))+((sj2*x823))+((cj1*r22))+(((-1.0)*sj1*x825))+x827+((cj1*x827))))))+IKsqr((x821*(((((-1.0)*sj4))+(((-1.0)*x825))+npz+(((-1.0)*x823))+x826+x824+(((-1.0)*cj1*x825))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x821*(x829.value)*((((sj2*sj4))+(((-1.0)*x822*x826))+(((-1.0)*x822*x824))+(((-1.0)*npz*x822))+((sj1*x824))+((sj2*x823))+((cj1*r22))+(((-1.0)*sj1*x825))+x827+((cj1*x827))))), (x821*(((((-1.0)*sj4))+(((-1.0)*x825))+npz+(((-1.0)*x823))+x826+x824+(((-1.0)*cj1*x825))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x830=IKcos(j3);
IkReal x831=IKsin(j3);
IkReal x832=((1.0)*cj0);
IkReal x833=(pp*r12);
IkReal x834=((2.0)*sj1);
IkReal x835=(npz*pz);
IkReal x836=(cj1*rxp2_2);
IkReal x837=((1.0)*r22);
IkReal x838=(cj1*rxp2_1);
IkReal x839=((1.0)*sj0);
IkReal x840=(rxp2_0*sj0);
IkReal x841=((1.0)*cj2);
IkReal x842=((2.0)*cj0);
IkReal x843=(npz*px);
IkReal x844=((2.0)*r22);
IkReal x845=((2.0)*sj0);
IkReal x846=(npz*py);
IkReal x847=((2.0)*cj4);
IkReal x848=(pp*r02);
IkReal x849=(cj1*px);
IkReal x850=(cj1*r22);
IkReal x851=((2.0)*npz);
IkReal x852=(cj1*r12);
IkReal x853=(cj1*r02);
IkReal x854=(cj1*py);
IkReal x855=(r02*sj1);
IkReal x856=((1.0)*sj4);
IkReal x857=(r12*sj1);
IkReal x858=((2.0)*cj1);
IkReal x859=((1.0)*sj1);
IkReal x860=(sj0*sj1);
IkReal x861=((2.0)*sj4);
IkReal x862=((2.0)*x830);
IkReal x863=((1.0)*cj4*sj2);
IkReal x864=(sj4*x830);
IkReal x865=(sj2*x831);
IkReal x866=(cj4*x830);
IkReal x867=((1.0)*sj2*x830);
IkReal x868=(x831*x841);
IkReal x869=(x830*x847);
IkReal x870=(x830*x863);
IkReal x871=(cj4*x868);
IkReal x872=(sj4*x868);
IkReal x873=(x856*x865);
IkReal x874=(x869+x862);
IkReal x875=(x868+x867+x870+x871);
evalcond[0]=(((sj0*x855))+(((-1.0)*x832*x857))+x850+(((-1.0)*sj2*x830*x856))+(((-1.0)*x872)));
evalcond[1]=((((-1.0)*sj1*x837))+((cj2*x864))+((sj0*x853))+(((-1.0)*x832*x852))+(((-1.0)*x873)));
evalcond[2]=(sj4+(((-1.0)*r02*x839))+((r22*sj1))+(((-1.0)*x839*x853))+(((-1.0)*npz))+x864+((cj0*x852))+((cj0*r12)));
evalcond[3]=((((-1.0)*x839*x855))+(((-1.0)*x837))+(((-1.0)*x831*x856))+(((-1.0)*rxp2_1*x839))+(((-1.0)*rxp2_0*x832))+((cj0*x857))+(((-1.0)*cj1*x837)));
evalcond[4]=((1.0)+cj2+cj1+((cj2*x866))+(((-1.0)*x865))+(((-1.0)*x831*x863))+(((-1.0)*x832*x854))+(((-1.0)*pz*x859))+((cj2*x830))+((sj0*x849)));
evalcond[5]=((((-1.0)*sj2))+sj1+(((-1.0)*py*sj1*x832))+((cj1*pz))+((px*x860))+(((-1.0)*x875)));
evalcond[6]=((1.0)+((x842*x854))+(((-1.0)*x858))+(((-1.0)*px*x845))+((pz*x834))+((py*x842))+(((-1.0)*pp))+(((-1.0)*x845*x849))+x874+x847);
evalcond[7]=((((-1.0)*x863))+(((-1.0)*x832*x838))+((cj1*x840))+((sj0*x857))+((cj0*x855))+(((-1.0)*rxp2_2*x859))+(((-1.0)*x875)));
evalcond[8]=((((-1.0)*r02*x832))+(((-1.0)*x839*x852))+(((-1.0)*cj4*x841))+(((-1.0)*x841*x866))+(((-1.0)*x830*x841))+(((-1.0)*x832*x853))+(((-1.0)*r12*x839))+((cj4*x865))+x865+x836+(((-1.0)*rxp2_1*sj1*x832))+((sj1*x840)));
evalcond[9]=((2.0)+(((-1.0)*r02*x842))+(((-1.0)*x842*x853))+(((2.0)*x836))+(((-1.0)*x845*x852))+(((-1.0)*x833*x839))+(((3.0)*cj4))+(((-1.0)*cj0*rxp2_1*x834))+((x842*x843))+(((2.0)*rxp2_2))+((x834*x840))+((x845*x846))+(((-1.0)*r12*x845))+x874+(((-1.0)*x832*x848)));
evalcond[10]=(((x838*x845))+((cj1*x844))+((sj2*x864))+((sj2*x861))+((x848*x860))+((rxp2_1*x845))+(((-1.0)*sj1*x832*x833))+(((-1.0)*npz*x834))+((cj0*x834*x846))+((rxp2_0*x842))+((cj1*rxp2_0*x842))+(((-1.0)*x835*x858))+(((-1.0)*sj0*x834*x843))+x844+((pp*x850))+(((-1.0)*x872)));
evalcond[11]=((((-1.0)*pp*sj1*x837))+((cj1*sj0*x848))+(((-1.0)*r02*x845))+(((-1.0)*cj1*x832*x833))+((x842*x852))+(((-1.0)*x851))+(((-1.0)*x845*x853))+(((-1.0)*cj2*x861))+(((-1.0)*cj0*rxp2_0*x834))+(((-1.0)*x841*x864))+(((-1.0)*cj1*x851))+(((-1.0)*cj1*x843*x845))+((r12*x842))+((x834*x835))+(((-1.0)*rxp2_1*sj0*x834))+((cj1*x842*x846))+(((-1.0)*x873)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x884=IKPowWithIntegerCheck(sj4,-1);
if(!x884.valid){
continue;
}
IkReal x876=x884.value;
IkReal x877=(cj2*sj0);
IkReal x878=(r02*sj1);
IkReal x879=((1.0)*cj0);
IkReal x880=(cj2*r22);
IkReal x881=(r12*sj1);
IkReal x882=((1.0)*sj0);
IkReal x883=((1.0)*r22);
CheckValue<IkReal> x885=IKPowWithIntegerCheck(sj2,-1);
if(!x885.valid){
continue;
}
if( IKabs((x876*((((cj0*x881))+(((-1.0)*x883))+(((-1.0)*rxp2_1*x882))+(((-1.0)*cj1*x883))+(((-1.0)*rxp2_0*x879))+(((-1.0)*x878*x882)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x876*(x885.value)*(((((-1.0)*x879*x881))+((cj0*cj2*rxp2_0))+((cj1*r22))+((sj0*x878))+((cj1*x880))+x880+((rxp2_1*x877))+((x877*x878))+(((-1.0)*cj2*x879*x881)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x876*((((cj0*x881))+(((-1.0)*x883))+(((-1.0)*rxp2_1*x882))+(((-1.0)*cj1*x883))+(((-1.0)*rxp2_0*x879))+(((-1.0)*x878*x882))))))+IKsqr((x876*(x885.value)*(((((-1.0)*x879*x881))+((cj0*cj2*rxp2_0))+((cj1*r22))+((sj0*x878))+((cj1*x880))+x880+((rxp2_1*x877))+((x877*x878))+(((-1.0)*cj2*x879*x881))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x876*((((cj0*x881))+(((-1.0)*x883))+(((-1.0)*rxp2_1*x882))+(((-1.0)*cj1*x883))+(((-1.0)*rxp2_0*x879))+(((-1.0)*x878*x882))))), (x876*(x885.value)*(((((-1.0)*x879*x881))+((cj0*cj2*rxp2_0))+((cj1*r22))+((sj0*x878))+((cj1*x880))+x880+((rxp2_1*x877))+((x877*x878))+(((-1.0)*cj2*x879*x881))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x886=IKcos(j3);
IkReal x887=IKsin(j3);
IkReal x888=((1.0)*cj0);
IkReal x889=(pp*r12);
IkReal x890=((2.0)*sj1);
IkReal x891=(npz*pz);
IkReal x892=(cj1*rxp2_2);
IkReal x893=((1.0)*r22);
IkReal x894=(cj1*rxp2_1);
IkReal x895=((1.0)*sj0);
IkReal x896=(rxp2_0*sj0);
IkReal x897=((1.0)*cj2);
IkReal x898=((2.0)*cj0);
IkReal x899=(npz*px);
IkReal x900=((2.0)*r22);
IkReal x901=((2.0)*sj0);
IkReal x902=(npz*py);
IkReal x903=((2.0)*cj4);
IkReal x904=(pp*r02);
IkReal x905=(cj1*px);
IkReal x906=(cj1*r22);
IkReal x907=((2.0)*npz);
IkReal x908=(cj1*r12);
IkReal x909=(cj1*r02);
IkReal x910=(cj1*py);
IkReal x911=(r02*sj1);
IkReal x912=((1.0)*sj4);
IkReal x913=(r12*sj1);
IkReal x914=((2.0)*cj1);
IkReal x915=((1.0)*sj1);
IkReal x916=(sj0*sj1);
IkReal x917=((2.0)*sj4);
IkReal x918=((2.0)*x886);
IkReal x919=((1.0)*cj4*sj2);
IkReal x920=(sj4*x886);
IkReal x921=(sj2*x887);
IkReal x922=(cj4*x886);
IkReal x923=((1.0)*sj2*x886);
IkReal x924=(x887*x897);
IkReal x925=(x886*x903);
IkReal x926=(x886*x919);
IkReal x927=(cj4*x924);
IkReal x928=(sj4*x924);
IkReal x929=(x912*x921);
IkReal x930=(x925+x918);
IkReal x931=(x926+x927+x924+x923);
evalcond[0]=((((-1.0)*x928))+(((-1.0)*x888*x913))+(((-1.0)*sj2*x886*x912))+((sj0*x911))+x906);
evalcond[1]=((((-1.0)*x929))+((sj0*x909))+(((-1.0)*x888*x908))+((cj2*x920))+(((-1.0)*sj1*x893)));
evalcond[2]=(sj4+(((-1.0)*x895*x909))+((r22*sj1))+(((-1.0)*npz))+((cj0*x908))+(((-1.0)*r02*x895))+x920+((cj0*r12)));
evalcond[3]=((((-1.0)*x893))+(((-1.0)*x887*x912))+((cj0*x913))+(((-1.0)*rxp2_1*x895))+(((-1.0)*rxp2_0*x888))+(((-1.0)*cj1*x893))+(((-1.0)*x895*x911)));
evalcond[4]=((1.0)+((sj0*x905))+((cj2*x886))+cj2+cj1+(((-1.0)*x888*x910))+(((-1.0)*pz*x915))+(((-1.0)*x887*x919))+(((-1.0)*x921))+((cj2*x922)));
evalcond[5]=((((-1.0)*sj2))+sj1+((px*x916))+(((-1.0)*py*sj1*x888))+((cj1*pz))+(((-1.0)*x931)));
evalcond[6]=((1.0)+((x898*x910))+(((-1.0)*px*x901))+((py*x898))+((pz*x890))+(((-1.0)*x914))+(((-1.0)*pp))+(((-1.0)*x901*x905))+x930+x903);
evalcond[7]=((((-1.0)*rxp2_2*x915))+(((-1.0)*x919))+((cj0*x911))+(((-1.0)*x888*x894))+((cj1*x896))+((sj0*x913))+(((-1.0)*x931)));
evalcond[8]=((((-1.0)*x897*x922))+(((-1.0)*x888*x909))+((sj1*x896))+(((-1.0)*x895*x908))+(((-1.0)*r12*x895))+(((-1.0)*cj4*x897))+x892+(((-1.0)*r02*x888))+((cj4*x921))+x921+(((-1.0)*rxp2_1*sj1*x888))+(((-1.0)*x886*x897)));
evalcond[9]=((2.0)+(((2.0)*x892))+((x898*x899))+(((-1.0)*x888*x904))+((x901*x902))+(((-1.0)*r12*x901))+(((-1.0)*cj0*rxp2_1*x890))+(((3.0)*cj4))+(((-1.0)*x898*x909))+(((-1.0)*x889*x895))+(((2.0)*rxp2_2))+(((-1.0)*r02*x898))+(((-1.0)*x901*x908))+((x890*x896))+x930);
evalcond[10]=(((cj1*x900))+((rxp2_0*x898))+(((-1.0)*x928))+((pp*x906))+((rxp2_1*x901))+((x894*x901))+(((-1.0)*x891*x914))+((sj2*x917))+(((-1.0)*npz*x890))+((cj0*x890*x902))+((cj1*rxp2_0*x898))+(((-1.0)*sj0*x890*x899))+x900+((sj2*x920))+((x904*x916))+(((-1.0)*sj1*x888*x889)));
evalcond[11]=((((-1.0)*x897*x920))+(((-1.0)*x929))+(((-1.0)*x907))+(((-1.0)*cj1*x888*x889))+((cj1*sj0*x904))+(((-1.0)*cj0*rxp2_0*x890))+(((-1.0)*r02*x901))+(((-1.0)*x901*x909))+(((-1.0)*cj1*x899*x901))+(((-1.0)*pp*sj1*x893))+(((-1.0)*rxp2_1*sj0*x890))+((x890*x891))+((x898*x908))+(((-1.0)*cj1*x907))+((r12*x898))+((cj1*x898*x902))+(((-1.0)*cj2*x917)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x932=(r02*sj0);
IkReal x933=(cj2*sj1);
IkReal x934=(cj1*sj2);
IkReal x935=(cj1*cj2);
IkReal x936=(sj1*sj2);
IkReal x937=((1.0)*cj0*r12);
CheckValue<IkReal> x938 = IKatan2WithCheck(IkReal(((((-1.0)*r22*x936))+((r22*x935))+(((-1.0)*x934*x937))+(((-1.0)*x933*x937))+((x932*x934))+((x932*x933)))),IkReal((((r22*x934))+((r22*x933))+(((-1.0)*x932*x935))+(((-1.0)*x936*x937))+((cj0*r12*x935))+((x932*x936)))),IKFAST_ATAN2_MAGTHRESH);
if(!x938.valid){
continue;
}
CheckValue<IkReal> x939=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x939.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x938.value)+(((1.5707963267949)*(x939.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x940=IKcos(j3);
IkReal x941=IKsin(j3);
IkReal x942=((1.0)*cj0);
IkReal x943=(pp*r12);
IkReal x944=((2.0)*sj1);
IkReal x945=(npz*pz);
IkReal x946=(cj1*rxp2_2);
IkReal x947=((1.0)*r22);
IkReal x948=(cj1*rxp2_1);
IkReal x949=((1.0)*sj0);
IkReal x950=(rxp2_0*sj0);
IkReal x951=((1.0)*cj2);
IkReal x952=((2.0)*cj0);
IkReal x953=(npz*px);
IkReal x954=((2.0)*r22);
IkReal x955=((2.0)*sj0);
IkReal x956=(npz*py);
IkReal x957=((2.0)*cj4);
IkReal x958=(pp*r02);
IkReal x959=(cj1*px);
IkReal x960=(cj1*r22);
IkReal x961=((2.0)*npz);
IkReal x962=(cj1*r12);
IkReal x963=(cj1*r02);
IkReal x964=(cj1*py);
IkReal x965=(r02*sj1);
IkReal x966=((1.0)*sj4);
IkReal x967=(r12*sj1);
IkReal x968=((2.0)*cj1);
IkReal x969=((1.0)*sj1);
IkReal x970=(sj0*sj1);
IkReal x971=((2.0)*sj4);
IkReal x972=((2.0)*x940);
IkReal x973=((1.0)*cj4*sj2);
IkReal x974=(sj4*x940);
IkReal x975=(sj2*x941);
IkReal x976=(cj4*x940);
IkReal x977=((1.0)*sj2*x940);
IkReal x978=(x941*x951);
IkReal x979=(x940*x957);
IkReal x980=(x940*x973);
IkReal x981=(cj4*x978);
IkReal x982=(sj4*x978);
IkReal x983=(x966*x975);
IkReal x984=(x972+x979);
IkReal x985=(x980+x981+x977+x978);
evalcond[0]=((((-1.0)*x982))+(((-1.0)*sj2*x940*x966))+(((-1.0)*x942*x967))+((sj0*x965))+x960);
evalcond[1]=((((-1.0)*x983))+(((-1.0)*x942*x962))+((sj0*x963))+((cj2*x974))+(((-1.0)*sj1*x947)));
evalcond[2]=((((-1.0)*r02*x949))+((cj0*x962))+sj4+((r22*sj1))+(((-1.0)*npz))+(((-1.0)*x949*x963))+x974+((cj0*r12)));
evalcond[3]=((((-1.0)*rxp2_1*x949))+((cj0*x967))+(((-1.0)*x947))+(((-1.0)*cj1*x947))+(((-1.0)*x941*x966))+(((-1.0)*x949*x965))+(((-1.0)*rxp2_0*x942)));
evalcond[4]=((1.0)+(((-1.0)*pz*x969))+cj2+cj1+(((-1.0)*x975))+((cj2*x940))+(((-1.0)*x942*x964))+(((-1.0)*x941*x973))+((sj0*x959))+((cj2*x976)));
evalcond[5]=((((-1.0)*x985))+(((-1.0)*sj2))+sj1+((cj1*pz))+((px*x970))+(((-1.0)*py*sj1*x942)));
evalcond[6]=((1.0)+((x952*x964))+((py*x952))+(((-1.0)*pp))+(((-1.0)*px*x955))+(((-1.0)*x955*x959))+x984+x957+(((-1.0)*x968))+((pz*x944)));
evalcond[7]=((((-1.0)*x985))+((cj0*x965))+(((-1.0)*rxp2_2*x969))+((cj1*x950))+(((-1.0)*x942*x948))+((sj0*x967))+(((-1.0)*x973)));
evalcond[8]=((((-1.0)*r02*x942))+(((-1.0)*rxp2_1*sj1*x942))+((cj4*x975))+(((-1.0)*r12*x949))+(((-1.0)*x940*x951))+(((-1.0)*x942*x963))+((sj1*x950))+(((-1.0)*x951*x976))+(((-1.0)*cj4*x951))+(((-1.0)*x949*x962))+x975+x946);
evalcond[9]=((2.0)+((x955*x956))+((x952*x953))+((x944*x950))+(((3.0)*cj4))+(((-1.0)*x942*x958))+(((-1.0)*cj0*rxp2_1*x944))+(((2.0)*rxp2_2))+(((-1.0)*x943*x949))+(((-1.0)*r12*x955))+(((-1.0)*x955*x962))+(((-1.0)*x952*x963))+(((2.0)*x946))+x984+(((-1.0)*r02*x952)));
evalcond[10]=((((-1.0)*x982))+(((-1.0)*sj1*x942*x943))+((cj1*x954))+(((-1.0)*sj0*x944*x953))+(((-1.0)*npz*x944))+((pp*x960))+((x948*x955))+((x958*x970))+((rxp2_1*x955))+(((-1.0)*x945*x968))+((rxp2_0*x952))+((cj0*x944*x956))+((sj2*x974))+((sj2*x971))+x954+((cj1*rxp2_0*x952)));
evalcond[11]=(((x952*x962))+(((-1.0)*x983))+((cj1*sj0*x958))+(((-1.0)*rxp2_1*sj0*x944))+(((-1.0)*cj1*x942*x943))+(((-1.0)*cj1*x953*x955))+(((-1.0)*cj1*x961))+(((-1.0)*cj2*x971))+((cj1*x952*x956))+(((-1.0)*cj0*rxp2_0*x944))+(((-1.0)*x951*x974))+((x944*x945))+(((-1.0)*pp*sj1*x947))+((r12*x952))+(((-1.0)*x955*x963))+(((-1.0)*r02*x955))+(((-1.0)*x961)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
    }

}

}
}
}
    }
    }

}

}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - three_parallel_bot (2d668f5dcfd74609520ab16b6181b43d)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
